//----- Variables -----------------------------------------------------------------------------------------------------

*OAMDMA# = 160
*OAMDMAS = 49152
,c = 0
,joypad = 0
-keyRandom = 86
-LCDC = 11110011
-LCDS = 01000110
-LY = 67
-LYC = 88
-LYmask = 67
-scx = 0
-SCXMOD8 = 0
-STATUS = 0
-windowWasDrawn? = 0
-WLY = 16
-wx = 233
.DIV2 = 0
.DIVCYCLES = 28612
.DMAenable = 0
.DMAend = 39936
.DMAlength = 0
.DMAstart = 54272
.DMAtype = 0
.GBC? = 0
.HDMAenable = 0
.IME = 1
.instr = B6HALT
.instrID = 2
.Mpri = 1
.soundEnable = 1
.SPEED = 1
.Spri = 0
.spriteattributes = 00000000
.spriteCpal = 0
.spritesize = 8
.TAC1 = 0
.TAC2 = 0
.TACFLAG = 0
.tileB = 0x8000
.timenable = 0
.vbank = 0
.windowflag = 0
@PAL = 0
@PIX = 0
FPS = 37.517711512704
g = 40
Game Boy: _HALT = 1
Game Boy: _PC = 541
Game Boy: _SP = 53247
h = 6
i = 0
i = 6
k = 0
l = 0
loop = 65312
m = 0
render = 1
T1 = 159
T2 = 99
T3 = 1
T4 = 32774
T4.1 = 15
T4.2 = 15
T5 = 16609
T6 = 0
T7 = 230
T8 = 6
T9 = 16609
T10 = 16582
T11 = 1
target frames = 0
time1 = 2.926
time2 = 8322.7091529861
v = 0
x = 0
z = 0
_A = 2
_B = 1
_current bank = 1
_frames = 0.8
_frameskip = 2.4
_IEindex = 16800
_IFindex = 16560
_INTRdest = 72
_lineCyc = 396
_MBCnumber = 0
_PIXEL# = 10880
_R = 65344
_RE = 143.6236834377
_rom size = 2
_S = 0
_SIZE = 2
_STATcond1 = 0
_STATcond2 = 0
_T = 0
_X = 160
_XSHIFT = 160
_YSHIFT = 144
_Z = 243


//----- Lists ---------------------------------------------------------------------------------------------------------

$A = { }
$B = { }
$C = { 
    1
    2
}
*OAMidx = { 
    65136
    65024
    65132
    65028
    65140
    65144
}
*OAMx = { 
    52
    72
    53
    80
    100
    100
}
*OAMy = { 
    66
    64
    66
    64
    66
    66
}
*palette = { 
    #eef2ae
    #7eb97a
    #38786f
    #19394d
    #eef2ae
    #7eb97a
    #38786f
    #19394d
    #eef2ae
    #19394d
    #38786f
    #eef2ae
}
.addr2ptr = { }
.AND = { }
.OR = { }
.pointerStart = { 
    0
    0
    0
    8192
    8192
    12288
    16384
    16544
    16544
    16672
}
.ptr = { 
    0
    16384
    0
    1000000
    8192
    12288
    16384
    16544
    16544
    16672
}
.ptr index = { }
.vals = { 
    80
    248
}
.XOR = { }
2^x = { 
    1
    2
    4
    8
    16
    32
    64
    128
    256
    512
    1024
    2048
    4096
    8192
    16384
    32768
}
bin = { }
byteStack = { 
    118
}
dat = { }
Flag bits = { 
    0
    1
    0
    0
}
_cartridge stuff = { 
    0
    0
    2
    0
}
_DMGPALETTE = { 
    #19394d
    #38786f
    #7eb97a
    #eef2ae
}
_GBCPALETTELOOKUP = { }
_instrIDs = { 
    0
    10
    11
    12
    13
    13
    1
    22
    2
    4
    11
    12
    13
    13
    1
    22
    2
    10
    11
    12
    13
    13
    1
    23
    14
    4
    11
    12
    13
    13
    1
    23
    14
    10
    11
    12
    13
    13
    1
    2
    14
    4
    11
    12
    13
    13
    1
    2
    14
    10
    11
    12
    13
    13
    1
    2
    14
    4
    11
    12
    13
    13
    1
    2
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    2
    1
    1
    1
    1
    1
    1
    1
    1
    1
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    5
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    6
    7
    7
    7
    7
    7
    7
    7
    7
    8
    8
    8
    8
    8
    8
    8
    8
    9
    9
    9
    9
    9
    9
    9
    9
    6
    6
    6
    6
    6
    6
    6
    6
    15
    18
    16
    16
    17
    19
    5
    20
    15
    15
    16
    2
    17
    17
    5
    20
    15
    18
    16
    0
    17
    19
    6
    20
    15
    15
    16
    0
    17
    0
    6
    20
    24
    18
    24
    0
    0
    19
    7
    20
    25
    21
    26
    0
    0
    0
    8
    20
    24
    18
    24
    3
    0
    19
    9
    20
    25
    21
    26
    3
    0
    0
    6
    20
}
_instrParam = { 
    ~
    J23
    K023
    L+23
    M+2
    M-2
    A2U
    V0
    B0SP
    D23
    K123
    L-23
    M+3
    M-3
    A3U
    V1
    B1STOP
    J45
    K045
    L+45
    M+4
    M-4
    A4U
    W0
    N0
    D45
    K145
    L-45
    M+5
    M-5
    A5U
    W1
    N110
    J78
    K078+
    L+78
    M+7
    M-7
    A7U
    B2DAA
    N111
    D78
    K178+
    L-78
    M+8
    M-8
    A8U
    B3CPL
    N140
    JSP
    K078-
    L+SP
    M+9
    M-9
    A9U
    B4SCF
    N141
    DSP
    K178-
    L-SP
    M+1
    M-1
    A1U
    B5CCF
    A22
    A23
    A24
    A25
    A27
    A28
    A29
    A21
    A32
    A33
    A34
    A35
    A37
    A38
    A39
    A31
    A42
    A43
    A44
    A45
    A47
    A48
    A49
    A41
    A52
    A53
    A54
    A55
    A57
    A58
    A59
    A51
    A72
    A73
    A74
    A75
    A77
    A78
    A79
    A71
    A82
    A83
    A84
    A85
    A87
    A88
    A89
    A81
    A92
    A93
    A94
    A95
    A97
    A98
    B6HALT
    A91
    A12
    A13
    A14
    A15
    A17
    A18
    A19
    A11
    E02
    E03
    E04
    E05
    E07
    E08
    E09
    E01
    E12
    E13
    E14
    E15
    E17
    E18
    E19
    E11
    F02
    F03
    F04
    F05
    F07
    F08
    F09
    F01
    F12
    F13
    F14
    F15
    F17
    F18
    F19
    F11
    G02
    G03
    G04
    G05
    G07
    G08
    G09
    G01
    H02
    H03
    H04
    H05
    H07
    H08
    H09
    H01
    I02
    I03
    I04
    I05
    I07
    I08
    I09
    I01
    F22
    F23
    F24
    F25
    F27
    F28
    F29
    F21
    O110
    R23
    P110
    P000
    Q110
    S23
    E0U
    T0
    O111
    O000
    P111
    B7CB
    Q111
    Q000
    E1U
    T1
    O140
    R45
    P140
    -
    Q140
    S45
    F0U
    T2
    O141
    O200
    P141
    -
    Q141
    -
    F1U
    T3
    X0U
    R78
    X03
    -
    -
    S78
    G0U
    T4
    Y0
    U0
    Z0
    -
    -
    -
    H0U
    T5
    X1U
    R16
    X13
    C0
    -
    S16
    I0U
    T6
    Y1
    U1
    Z1
    C1
    -
    -
    F2U
    T7
}
_PALETTE RAM = { }
_pix = { }
_RAM = { }
_REGISTERS = { 
    88
    199
    0
    147
    128
    176
    2
    102
    227
}
_ROM = { }
_soundregs = { 
    0
    0
    0.5
    0
    0
    0
    0
    0
}


//----- Key pressed events --------------------------------------------------------------------------------------------

WhenKeyPressed(r)
{
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(emulate!!)
{
    Pen.Clear();
    Event.BroadcastAndWait("prune");
    Event.Broadcast("create sound");
    Call $load ROM(_ROM);
    Call get game title;
    Call __INIT;
    Call _setup;
    Game Boy: _PC = 256;
    time1 = Sensing.Timer();
    target frames = 0;
    FPS = 0;
    Event.Broadcast("text");
    Forever
    {
        Call .loop;
    }
}

WhenBroadcastReceived(Nuke all lists)
{
    List.DeleteAll(_GBCPALETTELOOKUP);
    List.DeleteAll(_ROM);
    List.DeleteAll(.AND);
    List.DeleteAll(.OR);
    List.DeleteAll(.XOR);
    List.DeleteAll(.XOR);
    List.DeleteAll(_RAM);
    List.DeleteAll(temp.0);
    List.DeleteAll(temp.1);
    List.DeleteAll(_pix);
    List.DeleteAll($A);
    List.DeleteAll($B);
    List.DeleteAll(.ptr index);
    List.DeleteAll(vol);
    List.DeleteAll(.addr2ptr);
    List.DeleteAll(FT.re);
    List.DeleteAll(FT.im);
    List.DeleteAll(bin);
    List.DeleteAll(.HEX);
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define $ab reset (warp=true)
{
    List.DeleteAll($A);
    List.DeleteAll($B);
    Repeat (8)
    {
        List.Add($A, 0);
    }
    Repeat (8)
    {
        List.Add($B, 0);
    }
}

Define $incA (warp=false)
{
    Repeat Until (($A[last] == 0) Or ($A[last] == ""))
    {
        List.DeleteItem($A, last);
    }
    List.ReplaceItem($A, last, 1);
    Repeat ((8 - List.Length($A)))
    {
        List.Add($A, 0);
    }
}

Define $incB (warp=false)
{
    Repeat Until (($B[last] == 0) Or ($B[last] == ""))
    {
        List.DeleteItem($B, last);
    }
    List.ReplaceItem($B, last, 1);
    Repeat ((8 - List.Length($B)))
    {
        List.Add($B, 0);
    }
}

Define $load ROM(string ROM) (warp=true)
{
    loop = 0;
    List.DeleteAll(_ROM);
    Repeat ((Variable.Length(ROM) / 2))
    {
        _RE = (0 + Operator.Join("0x", Operator.Join(Operator.LetterOf(ROM, ((loop * 2) + 1)), Operator.LetterOf(ROM, ((loop * 2) + 2)))));
        List.Add(_ROM, _RE);
        loop += 1;
    }
    List.DeleteAll(_cartridge stuff);
    List.Add(_cartridge stuff, _ROM[(0x143 + 1)]);
    List.Add(_cartridge stuff, _ROM[(0x147 + 1)]);
    List.Add(_cartridge stuff, 2^x[(_ROM[(0x148 + 1)] + 2)]);
    _rom size = _cartridge stuff[3];
    .GBC? = floor((_cartridge stuff[1] / 128));
    _Z = _ROM[(0x149 + 1)];
    If (_Z == 2)
    {
        List.Add(_cartridge stuff, 8);
    }
    Else
    {
        If (_Z == 3)
        {
            List.Add(_cartridge stuff, 32);
        }
        Else
        {
            If (_Z == 4)
            {
                List.Add(_cartridge stuff, 128);
            }
            Else
            {
                If (_Z == 5)
                {
                    List.Add(_cartridge stuff, 64);
                }
                Else
                {
                    List.Add(_cartridge stuff, 0);
                }
            }
        }
    }
}

Define $reset registers (warp=true)
{
    Game Boy: _PC = 256;
    Game Boy: _SP = 65534;
    -LY = 0;
    List.DeleteAll(_REGISTERS);
    If (.GBC? == 0)
    {
        List.Add(_REGISTERS, 1);
    }
    Else
    {
        List.Add(_REGISTERS, 17);
    }
    List.Add(_REGISTERS, 0);
    List.Add(_REGISTERS, 19);
    List.Add(_REGISTERS, 0);
    List.Add(_REGISTERS, 216);
    List.Add(_REGISTERS, 176);
    List.Add(_REGISTERS, 1);
    List.Add(_REGISTERS, 77);
    List.Add(_REGISTERS, 0);
    Call ~FLAGSWRITE;
}

Define &joypad (warp=true)
{
    T4.2 = T4.1;
    T4 = 15;
    List.DeleteAll($A);
    Call .Z = rMEM("0xFF00");
    List.Add($A, ((floor((_Z / 16)) % 2) == 0));
    List.Add($A, ((floor((_Z / 32)) % 2) == 0));
    T4 += (((($A[1] * joypad buttons[1]) > 0) Or (($A[2] * joypad buttons[5]) > 0)) * -8);
    T4 += (((($A[1] * joypad buttons[2]) > 0) Or (($A[2] * joypad buttons[6]) > 0)) * -4);
    T4 += (((($A[1] * joypad buttons[3]) > 0) Or (($A[2] * joypad buttons[7]) > 0)) * -2);
    T4 += (((($A[1] * joypad buttons[4]) > 0) Or (($A[2] * joypad buttons[8]) > 0)) * -1);
    T4.1 = T4;
    If (T4.1 < T4.2)
    {
        Call *set IF(4) ,(1);
    }
    Call .DMA write(((((_Z - (_Z % 16)) + T4) % 64) + 0xC0)) to("0xFF00");
    ,joypad = 0;
}

Define *decode sound from address(string X) (warp=true)
{
    List.DeleteAll(_soundregs);
    loop = (X + 4);
    Call .S = rMEM(loop);
    List.Add(_soundregs, (floor((_S / 128)) % 2));
    List.Add(_soundregs, (floor((_S / 64)) % 2));
    List.Add(_soundregs, (floor((_S / 1)) % 8));
    loop += -1;
    Call .S = rMEM(loop);
    List.ReplaceItem(_soundregs, last, ((_soundregs[last] * 256) + _S));
    loop += -1;
    Call .S = rMEM(loop);
    List.Add(_soundregs, (floor((_S / 16)) % 16));
    List.Add(_soundregs, (floor((_S / 8)) % 2));
    List.Add(_soundregs, (floor((_S / 1)) % 8));
    loop += -1;
    Call .S = rMEM(loop);
    List.Add(_soundregs, (floor((_S / 64)) % 4));
    List.Add(_soundregs, (floor((_S / 1)) % 64));
}

Define *goto(string x)(string y) (warp=true)
{
    Motion.GoToXY((((x + 0.5) * _SIZE) - _XSHIFT), (_YSHIFT - ((y + 0.5) * _SIZE)));
}

Define *monodecode palettes address(string addr) (warp=true)
{
    Call .Z = rMEM(addr);
    T1 = _Z;
    List.Add(*palette, _DMGPALETTE[(4 - (floor((T1 / 1)) % 4))]);
    List.Add(*palette, _DMGPALETTE[(4 - (floor((T1 / 4)) % 4))]);
    List.Add(*palette, _DMGPALETTE[(4 - (floor((T1 / 16)) % 4))]);
    List.Add(*palette, _DMGPALETTE[(4 - (floor((T1 / 64)) % 4))]);
}

Define *OAMsearch (warp=true)
{
    g = 0;
    List.DeleteAll(*OAMidx);
    List.DeleteAll(*OAMy);
    List.DeleteAll(*OAMx);
    Repeat (40)
    {
        .spritesize = (8 + (Operator.LetterOf(-LCDC, 6) * 8));
        Call .Z = rMEM((0xFE00 + (g * 4)));
        _Z += -16;
        If (List.Length(*OAMidx) < 10)
        {
            If ((Not ((-LY < _Z))) And (-LY < (_Z + .spritesize)))
            {
                List.Add(*OAMidx, (0xFE00 + (g * 4)));
                List.Add(*OAMy, _Z);
                Call .Z = rMEM(((0xFE00 + (g * 4)) + 1));
                List.Add(*OAMx, (_Z - 8));
            }
        }
        g += 1;
    }
    If (.GBC? == 0)
    {
        Call *sort by x position;
    }
}

Define *palette decode (warp=true)
{
    List.DeleteAll(*palette);
    Call *monodecode palettes address("0xFF47");
    Call *monodecode palettes address("0xFF48");
    Call *monodecode palettes address("0xFF49");
}

Define *render frame (warp=true)
{
    If (render == 0)
    {
        Stop(this script);
    }
    Pen.Clear();
    Call *goto(0)(0);
    Pen.Down();
    T1 = 0;
    T2 = 0;
    T3 = 1;
    i = 1;
    Repeat (23041)
    {
        i += 1;
        If (_pix[(i - 1)] == _pix[i])
        {
            T3 += 1;
        }
        Else
        {
            T1 += T3;
            Pen.SetPenColorToColor(_pix[(i - 1)]);
            control_while ?? - probably legacy function from Scratch 2.0;
            Call *goto(T1)(T2);
            T3 = 1;
        }
    }
    Pen.Clear();
}

Define *reset PPU (warp=true)
{
    Call *STATUS(0);
    Call *setLY(0);
    -WLY = 0;
    -windowWasDrawn? = 0;
    _lineCyc = 0;
    _PIXEL# = 0;
}

Define *set IF(string bit) ,(string val) (warp=true)
{
    If (val == 1)
    {
        Call .DMA write(.OR[(((_RAM[_IFindex] * 256) + 2^x[(bit + 1)]) + 1)]) to("0xFF0F");
    }
    Else
    {
        Call .DMA write(.AND[(((_RAM[_IFindex] * 256) + (255 - 2^x[(bit + 1)])) + 1)]) to("0xFF0F");
    }
}

Define *setLY(string n) (warp=true)
{
    -LY = n;
    Call .DMA write(n) to("0xFF44");
}

Define *set STAT(string bit) ,(string cond) (warp=true)
{
    Call ~set bit(bit) of(_RAM[(T9 + 1)]) to(( + cond));
    Call .DMA write(_RE) to("0xFF41");
}

Define *sort by x position (warp=true)
{
    If (List.Length(*OAMx) > 0)
    {
        h = 0;
        Repeat (List.Length(*OAMx))
        {
            h += 1;
            i = h;
            T2 = 0;
            control_while ?? - probably legacy function from Scratch 2.0;
        }
    }
}

Define *STATUS(string 2) (warp=true)
{
    _Z = _RAM[(.ptr[.addr2ptr[(0xFF41 + 1)]] + .ptr index[(0xFF41 + 1)])];
    -STATUS = 2;
    Call .DMA write(((_Z - (_Z % 4)) + 2)) to("0xFF41");
}

Define *swap(string a)(string b) (warp=true)
{
    T1 = *OAMidx[a];
    List.ReplaceItem(*OAMidx, a, *OAMidx[b]);
    List.ReplaceItem(*OAMidx, b, T1);
    T1 = *OAMx[a];
    List.ReplaceItem(*OAMx, a, *OAMx[b]);
    List.ReplaceItem(*OAMx, b, T1);
    T1 = *OAMy[a];
    List.ReplaceItem(*OAMy, a, *OAMy[b]);
    List.ReplaceItem(*OAMy, b, T1);
}

Define +convert freq to midi(string f) (warp=true)
{
    _RE = (((ln((f / 440)) / ln(2)) * 12) + 69);
}

Define +convert GB freq to MIDI(string f) (warp=false)
{
    _RE = (((ln(((131072 / (2048 - f)) / 440)) / ln(2)) * 12) + 69);
    If (_RE > 109)
    {
        _RE = -1;
    }
}

Define +update sound (warp=false)
{
    Call *decode sound from address("0xFF10");
    List.ReplaceItem(+AUDIO ENGINE duty cycle, 1, _soundregs[7]);
    Call +convert GB freq to MIDI(_soundregs[3]);
    List.ReplaceItem(+AUDIO ENGINE pitch, 1, _RE);
    List.ReplaceItem(+AUDIO ENGINE volume, 1, _soundregs[4]);
    Call *decode sound from address("0xFF15");
    List.ReplaceItem(+AUDIO ENGINE duty cycle, 2, _soundregs[7]);
    Call +convert GB freq to MIDI(_soundregs[3]);
    List.ReplaceItem(+AUDIO ENGINE pitch, 2, _RE);
    List.ReplaceItem(+AUDIO ENGINE volume, 2, _soundregs[4]);
    Call *decode sound from address("0xFF1A");
    Call +convert GB freq to MIDI(_soundregs[3]);
    List.ReplaceItem(+AUDIO ENGINE pitch, 3, _RE);
    List.ReplaceItem(+AUDIO ENGINE volume, 3, floor((15 / 2^x[(Operator.LetterOf(4012, (floor(((_soundregs[4] % 8) / 2)) + 1)) + 1)])));
    loop = "0xFF30";
    List.DeleteAll(+AUDIO ENGINE wavetable);
    Repeat (32)
    {
        Call .S = rMEM(loop);
        loop += 1;
        List.Add(+AUDIO ENGINE wavetable, (floor((_S / 16)) % 16));
        List.Add(+AUDIO ENGINE wavetable, (floor((_S / 1)) % 16));
    }
    Call *decode sound from address("0xFF1F");
    List.ReplaceItem(+AUDIO ENGINE duty cycle, 4, (floor((_soundregs[3] / 8)) % 2));
    If ((_soundregs[3] % 8) == 0)
    {
        List.ReplaceItem(_soundregs, 3, (_soundregs[3] + 0.5));
    }
    Call +convert freq to midi(((32768 / (_soundregs[3] % 8)) / (2^x[(floor((_soundregs[3] / 16)) + 1)] * 2)));
    List.ReplaceItem(+AUDIO ENGINE pitch, 4, _RE);
    List.ReplaceItem(+AUDIO ENGINE volume, 4, _soundregs[4]);
    Call .S = rMEM("0xFF24");
    _S = ((_S % 8) / 8);
    List.ReplaceItem(+AUDIO ENGINE volume, 1, (+AUDIO ENGINE volume[1] * _S));
    List.ReplaceItem(+AUDIO ENGINE volume, 2, (+AUDIO ENGINE volume[2] * _S));
    List.ReplaceItem(+AUDIO ENGINE volume, 3, (+AUDIO ENGINE volume[3] * _S));
    List.ReplaceItem(+AUDIO ENGINE volume, 4, (+AUDIO ENGINE volume[4] * _S));
    Call .S = rMEM("0xFF25");
    List.ReplaceItem(+AUDIO ENGINE pan, 1, ((floor((_S / 1)) % 2) - (floor((_S / 16)) % 2)));
    List.ReplaceItem(+AUDIO ENGINE pan, 2, ((floor((_S / 2)) % 2) - (floor((_S / 32)) % 2)));
    List.ReplaceItem(+AUDIO ENGINE pan, 3, ((floor((_S / 4)) % 2) - (floor((_S / 64)) % 2)));
    List.ReplaceItem(+AUDIO ENGINE pan, 4, ((floor((_S / 8)) % 2) - (floor((_S / 128)) % 2)));
}

Define .decodeCGBpalette(string #) (warp=true)
{
    List.ReplaceItem(_PALETTE RAM, ((# * 2) + 2), (_PALETTE RAM[((# * 2) + 2)] % 128));
    T6 = ((_PALETTE RAM[((# * 2) + 2)] * 256) + _PALETTE RAM[((# * 2) + 1)]);
    List.ReplaceItem(*palette, (# + 1), _GBCPALETTELOOKUP[(T6 + 1)]);
}

Define .DMA write(string b) to(string a) (warp=true)
{
    List.ReplaceItem(_RAM, (.ptr[.addr2ptr[(a + 1)]] + .ptr index[(a + 1)]), b);
}

Define .GDMA transfer (warp=true)
{
    Repeat (.DMAlength)
    {
        Call .S = rMEM(.DMAstart);
        Call .DMA write(_S) to(.DMAend);
        .DMAstart += 1;
        .DMAend += 1;
        Call _;
        If (.SPEED == 2)
        {
            Call _;
        }
        .DMAlength += -1;
    }
    .DMAenable = 0;
    Call .DMA write(255) to("0xFF55");
    Call write DMA;
}

Define .HDMA transfer (warp=true)
{
    If (.DMAlength > 0)
    {
        Repeat (16)
        {
            Call .S = rMEM(.DMAstart);
            Call .DMA write(_S) to(.DMAend);
            .DMAstart += 1;
            .DMAend += 1;
            Call _;
            If (.SPEED == 2)
            {
                Call _;
            }
            .DMAlength += -1;
        }
    }
    If (.DMAlength > 0)
    {
        Call .DMA write((floor((.DMAlength / 16)) - 1)) to("0xFF55");
    }
    Else
    {
        Call .DMA write(255) to("0xFF55");
        .DMAenable = 0;
    }
    .HDMAenable = 0;
    Call write DMA;
}

Define .INTRpush (warp=true)
{
    Game Boy: _SP = ((Game Boy: _SP - 1) % 65536);
    Call _;
    Call .write(Game Boy: _SP) byte(floor(((Game Boy: _PC / 256) % 256)));
    Call z;
    Call find bit;
    _A = _T;
    Call _;
    Game Boy: _SP = ((Game Boy: _SP - 1) % 65536);
    Call .write(Game Boy: _SP) byte(floor((Game Boy: _PC % 256)));
    Call _;
    If (_A == 0)
    {
        Game Boy: _PC = 0;
    }
    Else
    {
        Call *set IF(_B) ,(0);
        Game Boy: _PC = _INTRdest;
    }
}

Define .loop (warp=true)
{
    time2 = Sensing.DaysSince2000();
    Call __run cycles;
    FPS += (((1 / ((Sensing.DaysSince2000() - time2) * 86400)) - FPS) / 12);
}

Define .MBC handler(string type) a(string a) b(string b) (warp=true)
{
    If (type == 1)
    {
        If ((Not ((a < "0x2000"))) And (a < "0x4000"))
        {
            _R = ((b % 32) + ((b % 32) == 0));
            _current bank = ((_current bank - (_current bank % 32)) + ((_R % 32) % _rom size));
            Call _swap ROM bank X to(_current bank);
        }
    }
    Else
    {
        If (type == 3)
        {
            If ((Not ((a < "0x2000"))) And (a < "0x4000"))
            {
                _R = (b + (b == 0));
                If (b == 0)
                {
                    _current bank = 1;
                }
                Else
                {
                    _current bank = (b % 128);
                }
                Call _swap ROM bank X to(_current bank);
            }
            Else
            {
                If ((Not ((a < "0x4000"))) And (a < "0x6000"))
                {
                    List.ReplaceItem(.ptr, 4, (((b % _cartridge stuff[4]) * 8192) + .pointerStart[4]));
                }
            }
        }
        Else
        {
            If (type == 5)
            {
                If ((Not ((a < "0x2000"))) And (a < "0x3000"))
                {
                    _current bank = ((_current bank - (_current bank % 256)) + b);
                    Call _swap ROM bank X to(_current bank);
                }
                Else
                {
                    If ((Not ((a < "0x3000"))) And (a < "0x4000"))
                    {
                        _current bank = ((_current bank % 256) + ((b % 2) * 256));
                        Call _swap ROM bank X to(_current bank);
                    }
                    Else
                    {
                    }
                }
            }
        }
    }
}

Define .PIX (warp=true)
{
    Call .PIX(_X)(-LY);
    _PIXEL# += 1;
    List.ReplaceItem(_pix, _PIXEL#, *palette[(((@PAL * 4) + @PIX) + 1)]);
    _X += 1;
}

Define .PIX(string x)(string y) (warp=true)
{
    @PAL = 0;
    If (((x < -wx) Or (y < _RAM[(T9 + 10)])) Or (Operator.LetterOf(-LCDC, 3) == 0))
    {
        T1 = (x + -scx);
        T2 = (y + _RAM[(T9 + 2)]);
        .tileB = (0x9800 + (1024 * Operator.LetterOf(-LCDC, 5)));
    }
    Else
    {
        T1 = (x - -wx);
        T2 = -WLY;
        .tileB = (0x9800 + (1024 * Operator.LetterOf(-LCDC, 2)));
        .windowflag = 1;
    }
    If ((.GBC? == 1) Or (Operator.LetterOf(-LCDC, 8) == 1))
    {
        .vbank = 0;
        T4 = (.tileB + (((floor((T2 / 8)) % 32) * 32) + (floor((T1 / 8)) % 32)));
        If (.GBC? == 1)
        {
            Call .r(1)(T4);
            T5 = bin[(_Z + 1)];
            @PAL = (_Z % 8);
            .Mpri = Operator.LetterOf(-LCDC, 8);
            .vbank = Operator.LetterOf(T5, 5);
            .Spri = Operator.LetterOf(T5, 1);
            If (Operator.LetterOf(T5, 3) == 1)
            {
                T1 = (7 - T1);
            }
            If (Operator.LetterOf(T5, 2) == 1)
            {
                T2 = (7 - T2);
            }
        }
        Call .r(0)(T4);
        If ((Operator.LetterOf(-LCDC, 4) == 1) Or (_Z > 127))
        {
            .tileB = "0x8000";
        }
        Else
        {
            .tileB = "0x9000";
        }
        T4 = (.tileB + ((_Z * 16) + ((T2 % 8) * 2)));
        T11 = (8 - (T1 % 8));
        Call .r(.vbank)(T4);
        @PIX = (floor((_Z / 2^x[T11])) % 2);
        Call .r(.vbank)((T4 + 1));
        @PIX += ((floor((_Z / 2^x[T11])) % 2) * 2);
    }
    Else
    {
        @PIX = 0;
    }
    If (Operator.LetterOf(-LCDC, 7) == 1)
    {
        .spritesize = (8 + (Operator.LetterOf(-LCDC, 6) * 8));
        i = 0;
        List.DeleteAll($A);
        Repeat (List.Length(*OAMx))
        {
            i += 1;
            If ((y < (*OAMy[i] + .spritesize)) And ((Not ((x < *OAMx[i]))) And (x < (*OAMx[i] + 8))))
            {
                List.Add($A, i);
            }
        }
        j = 1;
        Repeat (List.Length($A))
        {
            i = $A[j];
            j += 1;
            Call .Z = rMEM((*OAMidx[i] + 3));
            .vbank = 0;
            If (.GBC? == 1)
            {
                .vbank = (floor((_Z / 8)) % 2);
                .spriteCpal = (_Z % 8);
            }
            .spriteattributes = bin[(_Z + 1)];
            T1 = (x - *OAMx[i]);
            T2 = (y - *OAMy[i]);
            If (Operator.LetterOf(.spriteattributes, 3) == 1)
            {
                T1 = (7 - T1);
            }
            If (Operator.LetterOf(.spriteattributes, 2) == 1)
            {
                If (Operator.LetterOf(-LCDC, 6) == 1)
                {
                    T2 = (15 - T2);
                }
                Else
                {
                    T2 = (7 - T2);
                }
            }
            Call .Z = rMEM((*OAMidx[i] + 2));
            If (Operator.LetterOf(-LCDC, 6) == 1)
            {
                _Z = (_Z - (_Z % 2));
                If (Not ((T2 < 8)))
                {
                    _Z += 1;
                }
            }
            T4 = (0x8000 + ((_Z * 16) + ((T2 % 8) * 2)));
            Call .r(.vbank)(T4);
            T3 = (floor((_Z / 2^x[(8 - (T1 % 8))])) % 2);
            Call .r(.vbank)((T4 + 1));
            T3 += ((floor((_Z / 2^x[(8 - (T1 % 8))])) % 2) * 2);
            If ((T3 > 0) And ((@PIX == 0) Or (Not (((Operator.LetterOf(.spriteattributes, 1) == 1) Or ((.GBC? * (.Spri * .Mpri)) == 1))))))
            {
                @PIX = T3;
                If (.GBC? == 1)
                {
                    @PAL = (.spriteCpal + 8);
                }
                Else
                {
                    @PAL = (1 + Operator.LetterOf(.spriteattributes, 4));
                }
                Stop(this script);
            }
        }
    }
}

Define .ppu regs (warp=true)
{
    -LYC = _RAM[(T9 + 5)];
    -LCDC = bin[(_RAM[T9] + 1)];
    -LCDS = bin[(_RAM[(T9 + 1)] + 1)];
}

Define .r(string bank)(string addr) (warp=true)
{
    _Z = _RAM[((bank * 8192) + .ptr index[(addr + 1)])];
}

Define .S = rMEM(string a) (warp=true)
{
    T10 = (.ptr[.addr2ptr[(a + 1)]] + .ptr index[(a + 1)]);
    If (a < 32768)
    {
        _S = _ROM[T10];
    }
    Else
    {
        _S = _RAM[T10];
    }
}

Define .TIMERS (warp=true)
{
    .DIVCYCLES = ((.DIVCYCLES + 4) % 65536);
    Call .DMA write(floor((.DIVCYCLES / 256))) to("0xFF04");
    If (.TACFLAG == 1)
    {
        .TACFLAG = 0;
        Call .Z = rMEM("0xFF06");
        Call .DMA write(_Z) to("0xFF05");
        Call *set IF(2) ,(1);
    }
    Call .Z = rMEM("0xFF07");
    .timenable = (floor((_Z / 4)) % 2);
    .TAC2 = .TAC1;
    .TAC1 = ((.timenable * floor((.DIVCYCLES / 2^x[(Operator.LetterOf(9357, ((_Z % 4) + 1)) + 1)]))) % 2);
    If (.TAC1 < .TAC2)
    {
        Call .Z = rMEM("0xFF05");
        If (_Z == 255)
        {
            Call .DMA write(0) to("0xFF05");
            .TACFLAG = 1;
        }
        Else
        {
            Call .DMA write((_Z + 1)) to("0xFF05");
        }
    }
}

Define .write(string a) byte(string b) (warp=true)
{
    T5 = (.ptr[.addr2ptr[(a + 1)]] + .ptr index[(a + 1)]);
    If (a < 32768)
    {
        Call .MBC handler(_MBCnumber) a(a) b(b);
    }
    Else
    {
        List.ReplaceItem(_RAM, T5, b);
    }
    If (floor((a / 128)) == 510)
    {
        Call .ppu regs;
        If (a == "0xFF46")
        {
            *OAMDMA# = 0;
            If (b < "0xE0")
            {
                *OAMDMAS = (b * 256);
            }
            Else
            {
                *OAMDMAS = ((b - 32) * 256);
            }
            Stop(this script);
        }
        If (.GBC? == 1)
        {
            If (a == "0xFF4F")
            {
                List.ReplaceItem(.ptr, 3, ((b % 2) * 8192));
                Stop(this script);
            }
            If ((a == "0xFF68") Or (a == "0xFF6A"))
            {
                T6 = ((_RAM[T5] % 64) + ((a == "0xFF6A") * 64));
                List.ReplaceItem(_RAM, (T5 + 1), _PALETTE RAM[(T6 + 1)]);
                Stop(this script);
            }
            If ((a == "0xFF69") Or (a == "0xFF6B"))
            {
                T5 = (.ptr[.addr2ptr[((a - 1) + 1)]] + .ptr index[((a - 1) + 1)]);
                T6 = ((_RAM[T5] % 64) + ((a == "0xFF6B") * 64));
                List.ReplaceItem(_PALETTE RAM, (T6 + 1), b);
                Call .decodeCGBpalette(floor((T6 / 2)));
                T4 = floor((_RAM[T5] / 128));
                List.ReplaceItem(_RAM, T5, ((_RAM[T5] + T4) % 256));
                If ((_RAM[T5] == 0) And (T4 == 1))
                {
                    List.ReplaceItem(_RAM, T5, "0xC0");
                }
                Stop(this script);
            }
            If (a == "0xFF70")
            {
                List.ReplaceItem(.ptr, 6, (((b % 8) * 4096) + .pointerStart[6]));
                Stop(this script);
            }
            If (a == "0xFF55")
            {
                T5 = (.ptr[.addr2ptr[(0xFF50 + 1)]] + .ptr index[(0xFF50 + 1)]);
                If ((.DMAenable == 1) And (floor((b / 128)) == 0))
                {
                    .DMAenable = 0;
                    List.ReplaceItem(_RAM, (T5 + 5), (128 + (b % 128)));
                    Stop(this script);
                }
                .DMAstart = ((_RAM[(T5 + 1)] * 256) + _RAM[(T5 + 2)]);
                .DMAend = ((((_RAM[(T5 + 3)] % 32) + 128) * 256) + _RAM[(T5 + 4)]);
                .DMAstart = (.DMAstart - (.DMAstart % 16));
                .DMAend = (.DMAend - (.DMAend % 16));
                .DMAlength = (((b % 128) + 1) * 16);
                .DMAtype = floor((b / 128));
                If ((.DMAtype == 1) And (Operator.LetterOf(-LCDC, 1) == 0))
                {
                    .HDMAenable = 1;
                }
                .DMAenable = 1;
                List.ReplaceItem(_RAM, (T5 + 5), (b % 128));
                Stop(this script);
            }
            If (a == "0xFF4D")
            {
                List.ReplaceItem(_RAM, T5, (((.SPEED - 1) * 128) + (b % 2)));
                Stop(this script);
            }
        }
        If (a == "0xFF00")
        {
            ,joypad = 1;
            Stop(this script);
        }
        If ((.GBC? == 0) And (((a == "0xFF47") Or (a == "0xFF48")) Or (a == "0xFF49")))
        {
            Call *palette decode;
            Stop(this script);
        }
        If (a == "0xFF02")
        {
            List.ReplaceItem(_RAM, T5, .OR[(((_RAM[T5] * 256) + 0b01111100) + 1)]);
            Stop(this script);
        }
    }
}

Define .Z = rMEM(string a) (warp=true)
{
    T5 = (.ptr[.addr2ptr[(a + 1)]] + .ptr index[(a + 1)]);
    If (a < 32768)
    {
        _Z = _ROM[T5];
    }
    Else
    {
        _Z = _RAM[T5];
    }
}

Define CLS (warp=true)
{
    List.DeleteAll(_pix);
    Repeat (23040)
    {
        List.Add(_pix, "#000000");
    }
}

Define color correct(string R)(string G)(string B) (warp=false)
{
    List.DeleteAll($A);
    List.Add($A, (R * (255 / 31)));
    List.Add($A, (G * (255 / 31)));
    List.Add($A, (B * (255 / 31)));
    _RE = Operator.Join("#", Operator.Join(.HEX[($A[3] + 1)], Operator.Join(.HEX[($A[2] + 1)], .HEX[($A[1] + 1)])));
}

Define convert(string x) to base 16 (warp=true)
{
    _RE = Operator.Join(Operator.LetterOf("0123456789ABCDEF", (floor((x / 16)) + 1)), Operator.LetterOf("0123456789ABCDEF", (floor((x % 16)) + 1)));
}

Define CPU (warp=false)
{
    Call INTR;
    .IME = abs(.IME);
    If (Game Boy: _HALT == 1)
    {
        Call _;
        Stop(this script);
    }
    List.DeleteAll(byteStack);
    Call _;
    Call PC++;
    .instrID = (0 + _instrIDs[(byteStack[1] + 1)]);
    .instr = _instrParam[(byteStack[1] + 1)];
    If (.instrID < 16)
    {
        If (.instrID < 8)
        {
            If (.instrID < 4)
            {
                If (.instrID < 2)
                {
                    If (.instrID < 1)
                    {
                    }
                    Else
                    {
                        Call ~LD(Operator.LetterOf(.instr, 2))(Operator.LetterOf(.instr, 3));
                    }
                }
                Else
                {
                    If (.instrID < 3)
                    {
                        Call ~MISC(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        .IME = ( - Operator.LetterOf(.instr, 2));
                    }
                }
            }
            Else
            {
                If (.instrID < 6)
                {
                    If (.instrID < 5)
                    {
                        Call ~ADD HL,(Operator.LetterOf(.instr, 2))(Operator.LetterOf(.instr, 3));
                    }
                    Else
                    {
                        Call ~ADD A,(Operator.LetterOf(.instr, 3)) |(Operator.LetterOf(.instr, 2));
                    }
                }
                Else
                {
                    If (.instrID < 7)
                    {
                        Call ~SUB A,(Operator.LetterOf(.instr, 3)) |(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~AND A,(Operator.LetterOf(.instr, 3));
                    }
                }
            }
        }
        Else
        {
            If (.instrID < 12)
            {
                If (.instrID < 10)
                {
                    If (.instrID < 9)
                    {
                        Call ~XOR A,(Operator.LetterOf(.instr, 3));
                    }
                    Else
                    {
                        Call ~OR A,(Operator.LetterOf(.instr, 3));
                    }
                }
                Else
                {
                    If (.instrID < 11)
                    {
                        Call ~LD16(Operator.LetterOf(.instr, 2))(Operator.LetterOf(.instr, 3));
                    }
                    Else
                    {
                        Call ~LDPTR(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2))(Operator.LetterOf(.instr, 5));
                    }
                }
            }
            Else
            {
                If (.instrID < 14)
                {
                    If (.instrID < 13)
                    {
                        Call ~INC/DEC16(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~INC/DEC8(Operator.LetterOf(.instr, 3)) |(Operator.LetterOf(.instr, 2));
                    }
                }
                Else
                {
                    If (.instrID < 15)
                    {
                        Call ~JR(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~RET(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2));
                    }
                }
            }
        }
    }
    Else
    {
        If (.instrID < 24)
        {
            If (.instrID < 20)
            {
                If (.instrID < 18)
                {
                    If (.instrID < 17)
                    {
                        Call ~JP(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~CALL(Operator.LetterOf(.instr, 3))(Operator.LetterOf(.instr, 4)) |(Operator.LetterOf(.instr, 2));
                    }
                }
                Else
                {
                    If (.instrID < 19)
                    {
                        Call ~POP;
                        List.ReplaceItem(_REGISTERS, Operator.LetterOf(.instr, 2), floor((_T / 256)));
                        List.ReplaceItem(_REGISTERS, Operator.LetterOf(.instr, 3), (_T % 256));
                        If (Operator.LetterOf(.instr, 3) == 6)
                        {
                            Call ~FLAGSWRITE;
                        }
                    }
                    Else
                    {
                        If (Operator.LetterOf(.instr, 3) == 6)
                        {
                            Call ~FLAGSREAD;
                        }
                        Call ~PUSH(_REGISTERS[Operator.LetterOf(.instr, 2)])(_REGISTERS[Operator.LetterOf(.instr, 3)]);
                    }
                }
            }
            Else
            {
                If (.instrID < 22)
                {
                    If (.instrID < 21)
                    {
                        Call ~RST(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~JPHL/LDSPHL(Operator.LetterOf(.instr, 2));
                    }
                }
                Else
                {
                    If (.instrID < 23)
                    {
                        Call ~RLC/RRC(1) |(Operator.LetterOf(.instr, 2));
                    }
                    Else
                    {
                        Call ~RL/RR(1) |(Operator.LetterOf(.instr, 2));
                    }
                    List.ReplaceItem(Flag bits, 1, 0);
                }
            }
        }
        Else
        {
            If (.instrID < 28)
            {
                If (.instrID < 26)
                {
                    If (.instrID < 25)
                    {
                        Call ~LD ZRAM(Operator.LetterOf(.instr, 2))(Operator.LetterOf(.instr, 3));
                    }
                    Else
                    {
                        Call ~ADDSPI8/LDHLSP+I8(Operator.LetterOf(.instr, 2));
                    }
                }
                Else
                {
                    If (.instrID < 27)
                    {
                        Call ~LDU16(Operator.LetterOf(.instr, 2));
                    }
                }
            }
        }
    }
}

Define cycle (warp=true)
{
    If (.DMAenable == 1)
    {
        If (.DMAtype == 1)
        {
            If (.HDMAenable == 1)
            {
                Call .HDMA transfer;
            }
            Else
            {
                Call CPU;
            }
        }
        Else
        {
            Call .GDMA transfer;
        }
    }
    Else
    {
        Call CPU;
    }
}

Define find bit (warp=true)
{
    i = 8;
    control_while ?? - probably legacy function from Scratch 2.0;
    i = (8 - i);
    _B = i;
    _INTRdest = ((_B + 8) * 8);
}

Define generate table(string n) (warp=true)
{
    g = n;
    List.DeleteAll(bin);
    Repeat (n)
    {
        List.Add(bin, "");
    }
    Repeat (Operator.Round((ln(n) / ln(2))))
    {
        i = 0;
        _S = 0;
        g = floor((g / 2));
        Repeat (n)
        {
            List.ReplaceItem(bin, (i + 1), Operator.Join(bin[(i + 1)], _S));
            i += 1;
            If ((i % g) == 0)
            {
                _S = (1 - _S);
            }
        }
    }
}

Define get game title (warp=true)
{
    List.DeleteAll(_gametitle);
    _R = "0x134";
    Repeat (11)
    {
        Call .S = rMEM(_R);
        _R += 1;
        List.Add(_gametitle, _S);
    }
    control_while ?? - probably legacy function from Scratch 2.0;
}

Define INTR (warp=true)
{
    Call z;
    If (_T > 0)
    {
        Game Boy: _HALT = 0;
        If (.IME < 1)
        {
            Stop(this script);
        }
        Call .INTRpush;
        .IME = 0;
    }
}

Define PC++ (warp=true)
{
    Call .S = rMEM(Game Boy: _PC);
    List.Add(byteStack, _S);
    Game Boy: _PC = ((Game Boy: _PC + 1) % 65536);
}

Define update (warp=true)
{
    If (-LY < 144)
    {
        If (_lineCyc == 456)
        {
            Call *STATUS(2);
            _lineCyc = 0;
            _X = 0;
            Call *setLY((-LY + 1));
            -WLY += .windowflag;
            .windowflag = 0;
            If (-LY == 144)
            {
                Call *set IF(0) ,(1);
                Call *STATUS(1);
                Call *render frame;
                _frames += 1;
                If (render == 1)
                {
                    render = 0;
                }
                If (_frames > _frameskip)
                {
                    _frames += ( - _frameskip);
                    render = 1;
                }
                -WLY = 0;
            }
            If (-LY == -keyRandom)
            {
                Call update joypad and register;
            }
            Stop(this script);
        }
        If (_lineCyc == 80)
        {
            Call *OAMsearch;
            Call *STATUS(3);
            -SCXMOD8 = (_RAM[(T9 + 3)] % 8);
            Stop(this script);
        }
        If (_lineCyc == 248)
        {
            Call *STATUS(0);
            If ((.DMAenable * .DMAtype) == 1)
            {
                .HDMAenable = 1;
            }
            Stop(this script);
        }
    }
    Else
    {
        If (_lineCyc == 456)
        {
            _lineCyc = 0;
            Call *setLY((-LY + 1));
            If (-LY == 154)
            {
                Call *setLY(0);
                Call *STATUS(2);
                _PIXEL# = 0;
            }
        }
    }
}

Define update joypad (warp=true)
{
    List.DeleteAll(joypad buttons);
    List.Add(joypad buttons, ( + Sensing.KeyPressed(down arrow)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(up arrow)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(left arrow)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(right arrow)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(Operator.Join("enter", ""))));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(space)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(a)));
    List.Add(joypad buttons, ( + Sensing.KeyPressed(s)));
}

Define update joypad and register (warp=true)
{
    Call update joypad;
    Call &joypad;
}

Define update LCDSTAT (warp=true)
{
    _STATcond2 = _STATcond1;
    _STATcond1 = ( + ((-LYmask == -LYC) Or (((Operator.LetterOf(-LCDS, 3) * -STATUS) == 2) Or (((Operator.LetterOf(-LCDS, 4) * -STATUS) == 1) Or ((Operator.LetterOf(-LCDS, 5) * (-STATUS == 0)) == 1)))));
    Call *set STAT(2) ,(( + (-LYmask == -LYC)));
    If (_STATcond1 > _STATcond2)
    {
        Call *set IF(1) ,(1);
    }
}

Define view palette (warp=true)
{
    T1 = 64;
    Pen.SetPenSizeTo(10);
    Motion.SetY(0);
    Repeat (8)
    {
        Motion.SetX(-220);
        Repeat (4)
        {
            T1 += 1;
            Pen.SetPenColorToColor(*palette[T1]);
            Pen.Down();
            Pen.Clear();
            Motion.ChangeXBy(10);
        }
        Motion.ChangeYBy(-10);
    }
}

Define write DMA (warp=true)
{
    Call .DMA write(floor(((.DMAstart / 256) % 256))) to("0xFF51");
    Call .DMA write(floor((.DMAstart % 256))) to("0xFF52");
    Call .DMA write(floor(((.DMAend / 256) % 256))) to("0xFF53");
    Call .DMA write(floor((.DMAend % 256))) to("0xFF54");
}

Define z (warp=true)
{
    List.DeleteAll($C);
    List.Add($C, _RAM[_IFindex]);
    List.Add($C, _RAM[_IEindex]);
    _T = .AND[((($C[1] * 256) + $C[2]) + 1)];
}

Define _ (warp=true)
{
    _lineCyc += (4 / .SPEED);
    ,c += (4 / .SPEED);
    If (*OAMDMA# < 160)
    {
        Repeat (4)
        {
            Call .Z = rMEM((*OAMDMAS + *OAMDMA#));
            Call .DMA write(_Z) to((0xFE00 + *OAMDMA#));
            *OAMDMA# += 1;
        }
    }
    Call .TIMERS;
    Call .Z = rMEM("0xFF40");
    If (_Z < 128)
    {
        Call *reset PPU;
    }
    Else
    {
        If ((List.ContainsItem(.vals, _lineCyc) And (-LY < 144)) Or (_lineCyc == 456))
        {
            Call update;
        }
        If ((-STATUS * render) == 3)
        {
            If (_X < 160)
            {
                Call _graphics registers;
                Repeat ((2 / .SPEED))
                {
                    Call .PIX;
                    Call .PIX;
                }
            }
        }
        If ((-LY * (_lineCyc > 4)) == 153)
        {
            -LYmask = 0;
            Call .DMA write(0) to("0xFF44");
        }
        Else
        {
            -LYmask = -LY;
        }
        Call update LCDSTAT;
    }
}

Define _bitwise init (warp=true)
{
    Call $ab reset;
    List.DeleteAll(.AND);
    Repeat (256)
    {
        Repeat (256)
        {
            T1 = "0b";
            i = 0;
            Repeat (8)
            {
                i += 1;
                T1 = Operator.Join(T1, ( + ($A[i] And $B[i])));
            }
            Call $incA;
            List.Add(.AND, (T1 + 0));
        }
        Call $incB;
    }
    List.DeleteAll(.OR);
    Repeat (256)
    {
        Repeat (256)
        {
            T1 = "0b";
            i = 0;
            Repeat (8)
            {
                i += 1;
                T1 = Operator.Join(T1, ( + ($A[i] Or $B[i])));
            }
            Call $incA;
            List.Add(.OR, (T1 + 0));
        }
        Call $incB;
    }
    List.DeleteAll(.XOR);
    Repeat (256)
    {
        Repeat (256)
        {
            T1 = "0b";
            i = 0;
            Repeat (8)
            {
                i += 1;
                T1 = Operator.Join(T1, ( + (Not (($A[i] == $B[i])))));
            }
            Call $incA;
            List.Add(.XOR, (T1 + 0));
        }
        Call $incB;
    }
}

Define _graphics registers (warp=true)
{
    -scx = _RAM[(T9 + 3)];
    -scx = ((-scx - (-scx % 8)) + -SCXMOD8);
    -wx = (_RAM[(T9 + 11)] - 7);
}

Define _init cpu tables (warp=true)
{
    T1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    T2 = 0;
    List.DeleteAll($A);
    Repeat (26)
    {
        T2 += 1;
        List.Add($A, Operator.LetterOf(T1, T2));
    }
    T1 = "~ J23 K023 L+23 M+2 M-2 A2U V0 B0SP D23 K123 L-23 M+3 M-3 A3U V1 B1STOP J45 K045 L+45 M+4 M-4 A4U W0 N0 D45 K145 L-45 M+5 M-5 A5U W1 N110 J78 K078+ L+78 M+7 M-7 A7U B2DAA N111 D78 K178+ L-78 M+8 M-8 A8U B3CPL N140 JSP K078- L+SP M+9 M-9 A9U B4SCF N141 DSP K178- L-SP M+1 M-1 A1U B5CCF A22 A23 A24 A25 A27 A28 A29 A21 A32 A33 A34 A35 A37 A38 A39 A31 A42 A43 A44 A45 A47 A48 A49 A41 A52 A53 A54 A55 A57 A58 A59 A51 A72 A73 A74 A75 A77 A78 A79 A71 A82 A83 A84 A85 A87 A88 A89 A81 A92 A93 A94 A95 A97 A98 B6HALT A91 A12 A13 A14 A15 A17 A18 A19 A11 E02 E03 E04 E05 E07 E08 E09 E01 E12 E13 E14 E15 E17 E18 E19 E11 F02 F03 F04 F05 F07 F08 F09 F01 F12 F13 F14 F15 F17 F18 F19 F11 G02 G03 G04 G05 G07 G08 G09 G01 H02 H03 H04 H05 H07 H08 H09 H01 I02 I03 I04 I05 I07 I08 I09 I01 F22 F23 F24 F25 F27 F28 F29 F21 O110 R23 P110 P000 Q110 S23 E0U T0 O111 O000 P111 B7CB Q111 Q000 E1U T1 O140 R45 P140 - Q140 S45 F0U T2 O141 O200 P141 - Q141 - F1U T3 X0U R78 X03 - - S78 G0U T4 Y0 U0 Z0 - - - H0U T5 X1U R16 X13 C0 - S16 I0U T6 Y1 U1 Z1 C1 - - F2U T7";
    T2 = 0;
    T3 = "";
    List.DeleteAll(_instrParam);
    Repeat (Variable.Length(T1))
    {
        T2 += 1;
        If (Operator.LetterOf(T1, T2) == " ")
        {
            List.Add(_instrParam, T3);
            T3 = "";
        }
        Else
        {
            T3 = Operator.Join(T3, Operator.LetterOf(T1, T2));
        }
    }
    List.Add(_instrParam, T3);
    T3 = "";
    List.DeleteAll(_instrIDs);
    T2 = 0;
    Repeat (256)
    {
        T2 += 1;
        List.Add(_instrIDs, List.IndexOf($A, Operator.LetterOf(_instrParam[T2], 1)));
    }
}

Define _initMemPointers (warp=false)
{
    List.DeleteAll(.addr2ptr);
    List.DeleteAll(.pointerStart);
    List.DeleteAll(.ptr);
    List.DeleteAll(_RAM);
    List.DeleteAll(.ptr index);
    Call _new pointer length("0x4000") map to ram(2) offset("");
    Call _new pointer length("0x4000") map to ram(2) offset("");
    Call _new pointer length("0x2000") map to ram(1) offset("");
    Repeat ((.GBC? * 0x2000))
    {
        List.Add(_RAM, 0);
    }
    Call _new pointer length("0x2000") map to ram(0) offset("");
    If (_cartridge stuff[4] > 0)
    {
        Repeat ((_cartridge stuff[4] * 1024))
        {
            List.Add(_RAM, 0);
        }
    }
    Else
    {
        List.ReplaceItem(.ptr, 4, 1000000);
    }
    Call _new pointer length("0x1000") map to ram(1) offset("");
    Call _new pointer length("0x1000") map to ram(1) offset("");
    _S = .ptr[last];
    Repeat ((.GBC? * 0x7000))
    {
        List.Add(_RAM, 0);
    }
    Call _new pointer length("0x1000") map to ram(0) offset(2);
    Call _new pointer length("0xE00") map to ram(0) offset(2);
    Repeat (2)
    {
        List.DeleteItem(.pointerStart, last);
        List.DeleteItem(.ptr, last);
    }
    Call _new pointer length("0xA0") map to ram(1) offset("");
    Call _new pointer length("0x60") map to ram(0) offset("");
    Call _new pointer length("0x80") map to ram(1) offset("");
    Call _new pointer length("0x80") map to ram(1) offset("");
    List.ReplaceItem(.ptr, 2, 16384);
}

Define _new pointer length(string l) map to ram(string q) offset(string o) (warp=false)
{
    List.Add(.pointerStart, List.Length(_RAM));
    List.Add(.ptr, List.Length(_RAM));
    i = 0;
    Repeat (l)
    {
        List.Add(.addr2ptr, (List.Length(.pointerStart) - o));
        If (q == 1)
        {
            List.Add(_RAM, 0);
        }
        i += 1;
        List.Add(.ptr index, i);
    }
}

Define _setup (warp=true)
{
    List.DeleteAll(_DMGPALETTE);
    If 
    {
        List.Add(_DMGPALETTE, "#081820");
        List.Add(_DMGPALETTE, "#43654d");
        List.Add(_DMGPALETTE, "#7eb27a");
        List.Add(_DMGPALETTE, "#b9ffa8");
    }
    Else
    {
        List.Add(_DMGPALETTE, "#19394d");
        List.Add(_DMGPALETTE, "#38786f");
        List.Add(_DMGPALETTE, "#7eb97a");
        List.Add(_DMGPALETTE, "#eef2ae");
    }
    _SIZE = 2;
    Pen.SetPenSizeTo(_SIZE);
    _XSHIFT = 160;
    _YSHIFT = 144;
    .soundEnable = 1;
    time1 = Sensing.DaysSince2000();
}

Define _swap ROM bank X to(string n) (warp=true)
{
    List.ReplaceItem(.ptr, 2, (n * 16384));
}

Define __INIT (warp=true)
{
    List.DeleteAll(.HEX);
    control_for_each ?? - probably legacy function from Scratch 2.0;
    Call _bitwise init;
    _current bank = 1;
    loop = 0;
    _frames = 0;
    _frameskip = 2.4;
    .DIVCYCLES = 4;
    _lineCyc = 0;
    ,c = 0;
    .Mpri = 1;
    *OAMDMA# = 160;
    .DMAenable = 0;
    .DMAtype = 0;
    .HDMAenable = 0;
    .DIV2 = 0;
    Call _initMemPointers;
    Call .write("0xFF00") byte("0xFF");
    Call .write("0xFF13") byte(0);
    Call .write("0xFF14") byte(0);
    Call .write("0xFF40") byte("0x91");
    Call .write("0xFF4D") byte(((.GBC? == 0) * 255));
    Call .write("0xFF4F") byte(0);
    Call .write("0xFF68") byte(0);
    _R = 0;
    Game Boy: _HALT = 0;
    List.DeleteAll(_pix);
    -LY = 153;
    Call *reset PPU;
    Call CLS;
    Call generate table(256);
    Call $reset registers;
    Call _init cpu tables;
    .IME = 0;
    .TAC1 = 0;
    .TACFLAG = 0;
    List.DeleteAll(2^x);
    List.Add(2^x, 1);
    Repeat (15)
    {
        List.Add(2^x, (2 * 2^x[last]));
    }
    .SPEED = 1;
    _STATcond1 = 2;
    T9 = (.ptr[.addr2ptr[(0xFF40 + 1)]] + .ptr index[(0xFF40 + 1)]);
    _IFindex = (.ptr[.addr2ptr[(0xFF0F + 1)]] + .ptr index[(0xFF0F + 1)]);
    _IEindex = (.ptr[.addr2ptr[(0xFFFF + 1)]] + .ptr index[(0xFFFF + 1)]);
    If (_cartridge stuff[2] < 1)
    {
        _MBCnumber = 0;
    }
    Else
    {
        If (_cartridge stuff[2] < 3)
        {
            _MBCnumber = 1;
        }
        Else
        {
            If (_cartridge stuff[2] < "0x0A")
            {
                _MBCnumber = 0;
            }
            Else
            {
                If (_cartridge stuff[2] < "0x0E")
                {
                    _MBCnumber = "M1";
                }
                Else
                {
                    If (_cartridge stuff[2] < "0x14")
                    {
                        _MBCnumber = 3;
                    }
                    Else
                    {
                        If (_cartridge stuff[2] < "0x1F")
                        {
                            _MBCnumber = 5;
                        }
                        Else
                        {
                            If (_cartridge stuff[2] < "0x21")
                            {
                                _MBCnumber = 6;
                            }
                            Else
                            {
                                If (_cartridge stuff[2] < "0x22")
                                {
                                    _MBCnumber = 7;
                                }
                                Else
                                {
                                    _MBCnumber = "NA";
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    List.DeleteAll(_PALETTE RAM);
    List.DeleteAll(*palette);
    List.DeleteAll(.vals);
    List.Add(.vals, 80);
    List.Add(.vals, 248);
    If (.GBC? == 1)
    {
        Repeat (128)
        {
            List.Add(_PALETTE RAM, 0);
        }
        Repeat (64)
        {
            List.Add(*palette, "#000000");
        }
        List.DeleteAll(_GBCPALETTELOOKUP);
        T1 = 0;
        Repeat (32)
        {
            T2 = 0;
            Repeat (32)
            {
                T3 = 0;
                Repeat (32)
                {
                    Call color correct(T1)(T2)(T3);
                    List.Add(_GBCPALETTELOOKUP, _RE);
                    T3 += 1;
                }
                T2 += 1;
            }
            T1 += 1;
        }
        _A = 0;
        Repeat (5)
        {
            List.ReplaceItem(*palette, (_A + 1), Operator.Join("#", "F0F0F0"));
            List.ReplaceItem(*palette, (_A + 2), Operator.Join("#", "A0A0A0"));
            List.ReplaceItem(*palette, (_A + 3), Operator.Join("#", 505050));
            List.ReplaceItem(*palette, (_A + 4), Operator.Join("#", 000000));
            _A += 4;
        }
    }
}

Define __run cycles (warp=true)
{
    -keyRandom = Operator.Random(1 / 144);
    control_while ?? - probably legacy function from Scratch 2.0;
    ,c += -70224;
    Call +update sound;
}

Define ~ADD A,(string r1) |(string p1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r1 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r1];
        }
    }
    List.ReplaceItem(Flag bits, 3, ( + ((((_REGISTERS[1] % 16) + (_S % 16)) + (Flag bits[4] * (p1 == 1))) > 15)));
    List.ReplaceItem(Flag bits, 2, 0);
    _S += ((Flag bits[4] * (p1 == 1)) + _REGISTERS[1]);
    List.ReplaceItem(Flag bits, 4, ( + (_S > 255)));
    List.ReplaceItem(_REGISTERS, 1, (_S % 256));
    List.ReplaceItem(Flag bits, 1, ( + (_REGISTERS[1] == 0)));
}

Define ~ADD HL,(string r1)(string r2) (warp=true)
{
    Call _;
    If (r1 == "S")
    {
        _S = Game Boy: _SP;
    }
    Else
    {
        _S = ((_REGISTERS[r1] * 256) + _REGISTERS[r2]);
    }
    _T = ((_REGISTERS[7] * 256) + _REGISTERS[8]);
    List.ReplaceItem(Flag bits, 3, ( + (((_T % 4096) + (_S % 4096)) > 4095)));
    List.ReplaceItem(Flag bits, 2, 0);
    _T += _S;
    List.ReplaceItem(Flag bits, 4, ( + (_T > 65535)));
    List.ReplaceItem(_REGISTERS, 7, floor(((_T / 256) % 256)));
    List.ReplaceItem(_REGISTERS, 8, (_T % 256));
}

Define ~ADDSPI8/LDHLSP+I8(string p1) (warp=true)
{
    List.ReplaceItem(Flag bits, 1, 0);
    List.ReplaceItem(Flag bits, 2, 0);
    Call PC++;
    Call _;
    _T = (byteStack[2] - ((byteStack[2] > 127) * 256));
    List.ReplaceItem(Flag bits, 3, ( + ((((Game Boy: _SP % 16) + (_T % 16)) % 32) > 15)));
    List.ReplaceItem(Flag bits, 4, ( + ((((Game Boy: _SP % 256) + (_T % 256)) % 512) > 255)));
    Call _;
    If (p1 == 0)
    {
        Call _;
        Game Boy: _SP = ((Game Boy: _SP + _T) % 65536);
    }
    Else
    {
        List.ReplaceItem(_REGISTERS, 7, (floor(((Game Boy: _SP + _T) / 256)) % 256));
        List.ReplaceItem(_REGISTERS, 8, ((Game Boy: _SP + _T) % 256));
    }
}

Define ~AND A,(string r1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r1 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r1];
        }
    }
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 3, 1);
    List.ReplaceItem(Flag bits, 4, 0);
    List.ReplaceItem(_REGISTERS, 1, .AND[(((_REGISTERS[1] * 256) + _S) + 1)]);
    List.ReplaceItem(Flag bits, 1, ( + (_REGISTERS[1] == 0)));
}

Define ~CALL(string c1)(string c2) |(string p1) (warp=true)
{
    Call _;
    Call PC++;
    Call _;
    Call PC++;
    If ((p1 == 0) Or (Flag bits[c1] == c2))
    {
        Call ~PUSH(floor((Game Boy: _PC / 256)))((Game Boy: _PC % 256));
        Game Boy: _PC = ((byteStack[3] * 256) + byteStack[2]);
    }
}

Define ~CB prefixed (warp=false)
{
    Call _;
    Call PC++;
    T7 = byteStack[2];
    T8 = (T7 % 8);
    If (T8 == 6)
    {
        _R = ((_REGISTERS[7] * 256) + _REGISTERS[8]);
        Call .S = rMEM(_R);
        _T = _S;
        Call _;
    }
    Else
    {
        _T = _REGISTERS[Operator.LetterOf(23457891, (T8 + 1))];
    }
    List.ReplaceItem(_REGISTERS, 9, _T);
    If (T7 < 128)
    {
        If (T7 < 64)
        {
            If (T7 < 32)
            {
                If (T7 < 16)
                {
                    Call ~RLC/RRC(9) |(floor(((T7 % 16) / 8)));
                }
                Else
                {
                    Call ~RL/RR(9) |(floor(((T7 % 16) / 8)));
                }
            }
            Else
            {
                If (T7 < 48)
                {
                    Call ~SLA/SRA(9) |(floor(((T7 % 16) / 8)));
                }
                Else
                {
                    Call ~SWAP/SRL(9) |(floor(((T7 % 16) / 8)));
                }
            }
            _RE = _REGISTERS[9];
        }
        Else
        {
            List.ReplaceItem(Flag bits, 1, ( + ((floor((_REGISTERS[9] / 2^x[(floor(((T7 % 64) / 8)) + 1)])) % 2) == 0)));
            List.ReplaceItem(Flag bits, 2, 0);
            List.ReplaceItem(Flag bits, 3, 1);
            Stop(this script);
        }
    }
    Else
    {
        Call ~set bit(floor(((T7 % 64) / 8))) of(_REGISTERS[9]) to(floor(((T7 % 128) / 64)));
    }
    If (T8 == 6)
    {
        Call .write(_R) byte(_RE);
        Call _;
    }
    Else
    {
        List.ReplaceItem(_REGISTERS, Operator.LetterOf(23457891, (T8 + 1)), _RE);
    }
}

Define ~DAA (warp=true)
{
    If Flag bits[2]
    {
        If Flag bits[4]
        {
            List.ReplaceItem(_REGISTERS, 1, (_REGISTERS[1] - 96));
        }
        If Flag bits[3]
        {
            List.ReplaceItem(_REGISTERS, 1, (_REGISTERS[1] - 6));
        }
    }
    Else
    {
        If (Flag bits[4] Or (_REGISTERS[1] > "0x99"))
        {
            List.ReplaceItem(_REGISTERS, 1, (_REGISTERS[1] + 96));
            List.ReplaceItem(Flag bits, 4, 1);
        }
        If (Flag bits[3] Or ((_REGISTERS[1] % 16) > 9))
        {
            List.ReplaceItem(_REGISTERS, 1, (_REGISTERS[1] + 6));
        }
    }
    List.ReplaceItem(_REGISTERS, 1, (_REGISTERS[1] % 256));
    List.ReplaceItem(Flag bits, 3, 0);
    List.ReplaceItem(Flag bits, 1, ( + (_REGISTERS[1] == 0)));
}

Define ~FLAGSREAD (warp=true)
{
    List.ReplaceItem(_REGISTERS, 6, ((Flag bits[1] * 128) + ((Flag bits[2] * 64) + ((Flag bits[3] * 32) + (Flag bits[4] * 16)))));
}

Define ~FLAGSWRITE (warp=true)
{
    List.DeleteAll(Flag bits);
    List.Add(Flag bits, (floor((_REGISTERS[6] / 128)) % 2));
    List.Add(Flag bits, (floor((_REGISTERS[6] / 64)) % 2));
    List.Add(Flag bits, (floor((_REGISTERS[6] / 32)) % 2));
    List.Add(Flag bits, (floor((_REGISTERS[6] / 16)) % 2));
}

Define ~INC/DEC8(string r1) |(string p1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        _S = _REGISTERS[r1];
    }
    T7 = ((p1 == "+") - (p1 == "-"));
    _T = (_S + T7);
    List.ReplaceItem(Flag bits, 2, ( + (p1 == "-")));
    If Flag bits[2]
    {
        List.ReplaceItem(Flag bits, 3, (1 - ((((_S % 16) + (T7 % 16)) % 32) > 15)));
    }
    Else
    {
        List.ReplaceItem(Flag bits, 3, ( + ((((_S % 16) + (T7 % 16)) % 32) > 15)));
    }
    If (r1 == 9)
    {
        Call _;
        Call .write(((_REGISTERS[7] * 256) + _REGISTERS[8])) byte((_T % 256));
    }
    Else
    {
        List.ReplaceItem(_REGISTERS, r1, (_T % 256));
    }
    List.ReplaceItem(Flag bits, 1, ( + ((_T % 256) == 0)));
}

Define ~INC/DEC16(string r1)(string r2) |(string p1) (warp=true)
{
    _S = ((p1 == "+") - (p1 == "-"));
    Call _;
    If (r1 == "S")
    {
        Game Boy: _SP = ((Game Boy: _SP + _S) % 65536);
    }
    Else
    {
        _T = (_REGISTERS[r2] + _S);
        List.ReplaceItem(_REGISTERS, r2, (_T % 256));
        List.ReplaceItem(_REGISTERS, r1, ((_REGISTERS[r1] + floor((_T / 256))) % 256));
    }
}

Define ~JP(string c1)(string c2) |(string p1) (warp=true)
{
    Call PC++;
    Call _;
    Call PC++;
    Call _;
    If ((p1 == 0) Or (Flag bits[c1] == c2))
    {
        Game Boy: _PC = ((byteStack[3] * 256) + byteStack[2]);
        Call _;
    }
}

Define ~JPHL/LDSPHL(string r1) (warp=true)
{
    If (r1 == 0)
    {
        Game Boy: _PC = ((_REGISTERS[7] * 256) + _REGISTERS[8]);
    }
    Else
    {
        Call _;
        Game Boy: _SP = ((_REGISTERS[7] * 256) + _REGISTERS[8]);
    }
}

Define ~JR(string c1)(string c2) |(string p1) (warp=true)
{
    Call _;
    Call PC++;
    If ((p1 == 0) Or (Flag bits[c1] == c2))
    {
        Call _;
        Game Boy: _PC = ((Game Boy: _PC + (byteStack[2] - ((byteStack[2] > 127) * 256))) % 65536);
    }
}

Define ~LD(string r1)(string r2) (warp=true)
{
    If (r2 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r2 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r2];
        }
    }
    If (r1 == 9)
    {
        Call _;
        Call .write(((_REGISTERS[7] * 256) + _REGISTERS[8])) byte(_S);
    }
    Else
    {
        List.ReplaceItem(_REGISTERS, r1, _S);
    }
}

Define ~LD16(string r1)(string r2) (warp=true)
{
    Call _;
    Call PC++;
    Call _;
    Call PC++;
    If (r1 == "S")
    {
        Game Boy: _SP = ((byteStack[3] * 256) + byteStack[2]);
    }
    Else
    {
        List.ReplaceItem(_REGISTERS, r1, byteStack[3]);
        List.ReplaceItem(_REGISTERS, r2, byteStack[2]);
    }
}

Define ~LDPTR(string r1)(string r2) |(string p1)(string p2) (warp=true)
{
    Call _;
    If (p1 == 0)
    {
        Call .write(((_REGISTERS[r1] * 256) + _REGISTERS[r2])) byte(_REGISTERS[1]);
    }
    Else
    {
        Call .S = rMEM(((_REGISTERS[r1] * 256) + _REGISTERS[r2]));
        List.ReplaceItem(_REGISTERS, 1, _S);
    }
    If (p2 > "")
    {
        _S = ((p2 == "+") - (p2 == "-"));
        _T = (_REGISTERS[8] + _S);
        List.ReplaceItem(_REGISTERS, 8, (_T % 256));
        List.ReplaceItem(_REGISTERS, 7, floor((_REGISTERS[7] + (_T / 256))));
    }
}

Define ~LDU16(string p1) (warp=true)
{
    Call _;
    Call PC++;
    Call _;
    Call PC++;
    Call _;
    If (p1 == 0)
    {
        Call .write(((byteStack[3] * 256) + byteStack[2])) byte(_REGISTERS[1]);
    }
    Else
    {
        Call .S = rMEM(((byteStack[3] * 256) + byteStack[2]));
        List.ReplaceItem(_REGISTERS, 1, _S);
    }
}

Define ~LD ZRAM(string p1)(string p2) (warp=true)
{
    _T = "0xFF00";
    If (p2 == "U")
    {
        Call _;
        Call PC++;
        _T += byteStack[2];
    }
    Else
    {
        _T += _REGISTERS[3];
    }
    Call _;
    If (p1 == 0)
    {
        Call .write(_T) byte(_REGISTERS[1]);
    }
    Else
    {
        Call .S = rMEM(_T);
        List.ReplaceItem(_REGISTERS, 1, _S);
    }
}

Define ~MISC(string p1) (warp=true)
{
    If (p1 < 4)
    {
        If (p1 < 2)
        {
            If (p1 < 1)
            {
                Call _;
                Call PC++;
                Call _;
                Call PC++;
                _T = ((byteStack[3] * 256) + byteStack[2]);
                Call _;
                Call .write(_T) byte((Game Boy: _SP % 256));
                Call _;
                Call .write(((_T + 1) % 65536)) byte(floor((Game Boy: _SP / 256)));
            }
            Else
            {
                If (.GBC? == 1)
                {
                    .DIVCYCLES = 0;
                    Call _;
                    Call .S = rMEM("0xFF4D");
                    If ((_S % 2) == 1)
                    {
                        If (.SPEED == 1)
                        {
                            .SPEED = 2;
                        }
                        Else
                        {
                            .SPEED = 1;
                        }
                        Call .DMA write(((.SPEED - 1) * 128)) to("0xFF4D");
                        _lineCyc = (_lineCyc - (_lineCyc % 4));
                        Call PC++;
                    }
                }
                Else
                {
                }
            }
        }
        Else
        {
            If (p1 < 3)
            {
                Call ~DAA;
            }
            Else
            {
                List.ReplaceItem(_REGISTERS, 1, (255 - _REGISTERS[1]));
                List.ReplaceItem(Flag bits, 2, 1);
                List.ReplaceItem(Flag bits, 3, 1);
            }
        }
    }
    Else
    {
        If (p1 < 6)
        {
            If (p1 < 5)
            {
                List.ReplaceItem(Flag bits, 4, 1);
            }
            Else
            {
                List.ReplaceItem(Flag bits, 4, (1 - Flag bits[4]));
            }
            List.ReplaceItem(Flag bits, 2, 0);
            List.ReplaceItem(Flag bits, 3, 0);
        }
        Else
        {
            If (p1 < 7)
            {
                Game Boy: _HALT = 1;
            }
            Else
            {
                Call ~CB prefixed;
            }
        }
    }
}

Define ~OR A,(string r1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r1 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r1];
        }
    }
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 3, 0);
    List.ReplaceItem(Flag bits, 4, 0);
    List.ReplaceItem(_REGISTERS, 1, .OR[(((_REGISTERS[1] * 256) + _S) + 1)]);
    List.ReplaceItem(Flag bits, 1, ( + (_REGISTERS[1] == 0)));
}

Define ~POP (warp=true)
{
    Call _;
    Call .S = rMEM(Game Boy: _SP);
    _T = _S;
    Game Boy: _SP = ((Game Boy: _SP + 1) % 65536);
    Call _;
    Call .S = rMEM(Game Boy: _SP);
    _T += (_S * 256);
    Game Boy: _SP = ((Game Boy: _SP + 1) % 65536);
}

Define ~PUSH(string uH)(string uL) (warp=true)
{
    Call _;
    Game Boy: _SP = ((Game Boy: _SP - 1) % 65536);
    Call _;
    Call .write(Game Boy: _SP) byte(uH);
    Game Boy: _SP = ((Game Boy: _SP - 1) % 65536);
    Call _;
    Call .write(Game Boy: _SP) byte(uL);
}

Define ~RET(string c1)(string c2) |(string p1) (warp=true)
{
    If (((p1 == 0) Or (p1 == 2)) Or (Flag bits[c1] == c2))
    {
        If (p1 == 1)
        {
            Call _;
        }
        Call ~POP;
        Game Boy: _PC = _T;
    }
    If (p1 == 2)
    {
        .IME = -1;
    }
    Call _;
}

Define ~RL/RR(string r1) |(string d1) (warp=true)
{
    _S = _REGISTERS[r1];
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 3, 0);
    If (d1 == 0)
    {
        _S = ((_S * 2) + Flag bits[4]);
        List.ReplaceItem(Flag bits, 4, ( + (_S > 255)));
    }
    Else
    {
        _T = Flag bits[4];
        List.ReplaceItem(Flag bits, 4, (_S % 2));
        _S = (floor((_S / 2)) + (_T * 128));
    }
    _S = (_S % 256);
    List.ReplaceItem(Flag bits, 1, ( + (_S == 0)));
    List.ReplaceItem(_REGISTERS, r1, _S);
}

Define ~RLC/RRC(string r1) |(string d1) (warp=true)
{
    _S = _REGISTERS[r1];
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 3, 0);
    If (d1 == 0)
    {
        _S = ((_S * 2) + floor((_S / 128)));
        List.ReplaceItem(Flag bits, 4, ( + (_S > 255)));
    }
    Else
    {
        List.ReplaceItem(Flag bits, 4, (_S % 2));
        _S = (floor((_S / 2)) + ((_S % 2) * 128));
    }
    _S = (_S % 256);
    List.ReplaceItem(Flag bits, 1, ( + (_S == 0)));
    List.ReplaceItem(_REGISTERS, r1, _S);
}

Define ~RST(string n) (warp=true)
{
    Call ~PUSH(floor((Game Boy: _PC / 256)))((Game Boy: _PC % 256));
    Game Boy: _PC = (n * 8);
}

Define ~set bit(string x) of(string n) to(string b) (warp=true)
{
    _RE = ((n - (n % 2^x[(x + 2)])) + ((b * 2^x[(x + 1)]) + (n % 2^x[(x + 1)])));
}

Define ~SLA/SRA(string r1) |(string p1) (warp=true)
{
    _S = _REGISTERS[r1];
    If (p1 == 0)
    {
        _S = (_S * 2);
        List.ReplaceItem(Flag bits, 4, ( + (_S > 255)));
        _S = (_S % 256);
    }
    Else
    {
        List.ReplaceItem(Flag bits, 4, (_S % 2));
        _S = ((floor((_S / 2)) + (floor((_S / 128)) * 128)) % 256);
    }
    List.ReplaceItem(Flag bits, 3, 0);
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 1, ( + (_S == 0)));
    List.ReplaceItem(_REGISTERS, r1, _S);
}

Define ~SUB A,(string r1) |(string p1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r1 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r1];
        }
    }
    List.ReplaceItem(Flag bits, 3, ( + (((((_REGISTERS[1] % 16) - (_S % 16)) - (Flag bits[4] * (p1 == 1))) % 32) > 15)));
    List.ReplaceItem(Flag bits, 2, 1);
    _S += (Flag bits[4] * (p1 == 1));
    _S = (_REGISTERS[1] - _S);
    List.ReplaceItem(Flag bits, 4, ( + (_S < 0)));
    If (Not ((p1 == 2)))
    {
        List.ReplaceItem(_REGISTERS, 1, (_S % 256));
    }
    List.ReplaceItem(Flag bits, 1, ( + ((_S % 256) == 0)));
}

Define ~SWAP/SRL(string r1) |(string p1) (warp=true)
{
    _S = _REGISTERS[r1];
    If (p1 == 0)
    {
        List.ReplaceItem(Flag bits, 4, 0);
        _S = (((_S % 16) * 16) + floor((_S / 16)));
    }
    Else
    {
        List.ReplaceItem(Flag bits, 4, (_S % 2));
        _S = floor((_S / 2));
    }
    List.ReplaceItem(Flag bits, 3, 0);
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 1, ( + (_S == 0)));
    List.ReplaceItem(_REGISTERS, r1, _S);
}

Define ~XOR A,(string r1) (warp=true)
{
    If (r1 == 9)
    {
        Call _;
        Call .S = rMEM(((_REGISTERS[7] * 256) + _REGISTERS[8]));
    }
    Else
    {
        If (r1 == "U")
        {
            Call _;
            Call PC++;
            _S = byteStack[2];
        }
        Else
        {
            _S = _REGISTERS[r1];
        }
    }
    List.ReplaceItem(Flag bits, 2, 0);
    List.ReplaceItem(Flag bits, 3, 0);
    List.ReplaceItem(Flag bits, 4, 0);
    List.ReplaceItem(_REGISTERS, 1, .XOR[(((_REGISTERS[1] * 256) + _S) + 1)]);
    List.ReplaceItem(Flag bits, 1, ( + (_REGISTERS[1] == 0)));
}


//----- Orphaned blocks -----------------------------------------------------------------------------------------------

8

HALF_C

hc

8_1

0

1

pair

d1

d2


//----- Costumes ------------------------------------------------------------------------------------------------------

costume1.svg
