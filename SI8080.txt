//----- Variables -----------------------------------------------------------------------------------------------------

8080.cycles = 16683
8080.RAM mirror = 65536
8080.readreturn = 0x02
8080.shift register offset = 0
FPS = 333.34631771755
i = 8


//----- Lists ---------------------------------------------------------------------------------------------------------

_flags = { 
    1
    1
    1
    0
    0
    0
    0
    0
}


//----- Sprite clicked events -----------------------------------------------------------------------------------------

WhenThisSpriteClicked()
{
    Sound.Play(13);
    If (Costume.GetNumberName(number) == 2)
    {
        _PC = 0;
        8080.screenrotation = 0;
        8080.mode = 0;
        Stop(this script);
    }
    If (Costume.GetNumberName(number) == 3)
    {
        _PC = 256;
        8080.mode = 1;
        Stop(this script);
    }
    Sensing.Ask("Where should the ROM be loaded in memory?");
    _PC = Sensing.Answer();
    Sensing.Ask("How should the screen be oriented? (0=Vertical, 1=Horizontal)");
    8080.screenrotation = (Sensing.Answer() % 2);
    Sensing.Ask("What mode should be used? (0=Space Invaders, 1=CP/M HLE)");
    8080.mode = (Sensing.Answer() % 2);
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(8080)
{
    Call initialize;
}

WhenBroadcastReceived(clonekiller)
{
    Looks.Hide();
    Control.DeleteThisClone();
}

WhenBroadcastReceived(exit emulator)
{
    Stop(other scripts in sprite);
    Looks.Hide();
    Looks.SetSizeTo(100);
    Variable.Hide(_PC);
    List.Hide(_registers);
    Variable.Hide(8080.cycles);
    List.Hide(_memory);
    Variable.Hide(_SP);
    Variable.Hide(8080.InterruptFlag);
    Variable.Hide(FPS);
    List.DeleteAll(logzz);
    List.Hide(_flags);
    List.Hide(logzz);
    Control.DeleteThisClone();
}

WhenBroadcastReceived(Project not saving fix)
{
    List.DeleteAll(_memory);
}


//----- Start as clone ------------------------------------------------------------------------------------------------

Control.WhenIStartAsClone()
{
    Forever
    {
        If Sensing.TouchingObject(_mouse_)
        {
            If (Costume.GetNumberName(number) == 2)
            {
                Looks.Say("Starting Address = 0x0, Mode = 0 (screen)");
            }
            If (Costume.GetNumberName(number) == 3)
            {
                Looks.Say("Starting Address = 0x100, Mode = 1 (terminal)");
            }
        }
        Else
        {
            Looks.SetSizeTo(100);
            Looks.Say("");
        }
    }
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define 8080.boot (warp=false)
{
    8080.cycles = _PC;
    _SP = 356;
    8080.InterruptFlag = 0;
    8080.lastout = 420;
    List.DeleteAll(_registers);
    Repeat (9)
    {
        List.Add(_registers, 0);
    }
    List.DeleteAll(_flags);
    Repeat (8)
    {
        List.Add(_flags, 0);
    }
    List.ReplaceItem(_flags, 2, 1);
    List.DeleteAll(_memory);
    Repeat (65536)
    {
        List.Add(_memory, 0);
    }
    List.DeleteAll(_memorydirtyaddresses);
    List.DeleteAll(_memorydirtyflags);
    List.DeleteAll(_memorylastdrawndisplay);
    Repeat (7168)
    {
        List.Add(_memorydirtyflags, 0);
        List.Add(_memorylastdrawndisplay, -1);
    }
    8080.RAM mirror = 65536;
    List.DeleteAll(_colours);
    List.Add(_colours, "0x00000000");
    List.Add(_colours, "0xFFFFFF");
    List.Add(_colours, "0xFF0000");
    List.Add(_colours, "0x00FF00");
    If (8080.mode == 1)
    {
        List.ReplaceItem(_memory, 8, "0xC9");
    }
    8080.shift register offset = 0;
    control_clear_counter ?? - probably legacy function from Scratch 2.0;
    Repeat ((List.Length(_rom) + ))
    {
        List.ReplaceItem(_memory, (8080.cycles + 1), _rom[(control_get_counter ?? - probably legacy function from Scratch 2.0 + 1)]);
        8080.cycles += 1;
        control_incr_counter ?? - probably legacy function from Scratch 2.0;
    }
    List.DeleteAll(logzz);
    Variable.Show(FPS);
    Looks.SwitchBackdropTo(Black);
    Looks.Say("");
    Sound.StopAllSounds();
    Forever
    {
        Call 8080.frame;
    }
}

Define 8080.frame (warp=true)
{
    frame = Sensing.DaysSince2000();
    Call Step CPU(16667);
    Call Interrupt(1);
    Call Step CPU(16667);
    Call Interrupt(2);
    If (8080.mode == 0)
    {
        If (8080.screenrotation == 0)
        {
            Call render.vertical;
        }
        Else
        {
            Call render.horizontal;
        }
    }
    FPS = (1 / ((Sensing.DaysSince2000() - frame) * 86400));
}

Define ADC(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = (_registers[8] + (8080.readreturn + _flags[1]));
    List.ReplaceItem(_flags, 1, Operator.Round((r.1 > 255)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round((((_registers[8] % 16) + ((8080.readreturn + _flags[1]) % 16)) > 15)));
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    List.ReplaceItem(_registers, 8, (r.1 % 256));
}

Define ADD(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = (_registers[8] + 8080.readreturn);
    List.ReplaceItem(_flags, 1, Operator.Round((r.1 > 255)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round((((8080.readreturn % 16) + (_registers[8] % 16)) > 15)));
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    List.ReplaceItem(_registers, 8, (r.1 % 256));
}

Define ANA(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = and_table[(((_registers[8] * 256) + 8080.readreturn) + 1)];
    List.ReplaceItem(_flags, 1, 0);
    Call parity flag(bin_table[(r.1 + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round(((or_table[(((_registers[8] * 256) + 8080.readreturn) + 1)] % 9) > 0)));
    List.ReplaceItem(_flags, 7, Operator.Round((r.1 == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round((r.1 > 127)));
    List.ReplaceItem(_registers, 8, r.1);
}

Define CALL(bool condition) (warp=true)
{
    _PC += 2;
    If condition
    {
        _SP += -2;
        Call Write byte(_SP)((_PC % 256));
        Call Write byte((_SP + 1))(floor((_PC / 256)));
        Call Read byte((_PC - 2))(1);
        _PC = 8080.readreturn;
        8080.cycles += 6;
    }
    8080.cycles += 11;
}

Define CMP(string register) (warp=true)
{
    If (-1 == register)
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    Else
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    8080.readreturn = (256 - 8080.readreturn);
    r.1 = (_registers[8] + 8080.readreturn);
    List.ReplaceItem(_flags, 1, Operator.Round((256 > r.1)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round((((_registers[8] % 16) + (8080.readreturn % 16)) > 15)));
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
}

Define DAA (warp=true)
{
    r.1 = 0;
    If (((_registers[8] % 16) > 9) Or (_flags[5] == 1))
    {
        r.1 += 6;
    }
    List.ReplaceItem(_flags, 5, Operator.Round(((_registers[8] % 16) > 9)));
    If (((floor((_registers[8] / 16)) > 9) Or (_flags[1] == 1)) Or ((floor((_registers[8] / 16)) > 8) And ((_registers[8] % 16) > 9)))
    {
        r.1 += 96;
    }
    r.1 += _registers[8];
    List.ReplaceItem(_flags, 1, Operator.Round((r.1 > 255)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    List.ReplaceItem(_registers, 8, (r.1 % 256));
    8080.cycles += 4;
}

Define DAD(string regpair) (warp=true)
{
    r.1 = (((_registers[regpair] * 256) + _registers[(regpair + 1)]) + ((_registers[5] * 256) + _registers[6]));
    List.ReplaceItem(_flags, 1, Operator.Round((r.1 > 65535)));
    List.ReplaceItem(_registers, 5, floor(((r.1 % 65536) / 256)));
    List.ReplaceItem(_registers, 6, (r.1 % 256));
    8080.cycles += 10;
}

Define DAD SP (warp=true)
{
    r.1 = (_SP + ((_registers[5] * 256) + _registers[6]));
    List.ReplaceItem(_flags, 1, Operator.Round((r.1 > 65535)));
    List.ReplaceItem(_registers, 5, floor(((r.1 % 65536) / 256)));
    List.ReplaceItem(_registers, 6, (r.1 % 256));
    8080.cycles += 10;
}

Define IN (warp=true)
{
    Call Read byte(_PC)("");
    Call Read from device #(8080.readreturn);
    List.ReplaceItem(_registers, 8, 8080.readreturn);
    _PC += 1;
    8080.cycles += 10;
}

Define initialize (warp=false)
{
    Pen.Clear();
    Pen.Clear();
    Pen.SetPenSizeTo(1);
    8080.mode = 99;
    Looks.SwitchCostumeTo(SI);
    List.DeleteAll(8080.Terminal);
    Looks.Show();
    Motion.GoToXY(-141, 64);
    Repeat (2)
    {
        Control.CreateCloneOf(_myself_);
        Looks.NextCostume();
        Motion.ChangeYBy(-50);
    }
    Looks.SwitchCostumeTo(Manual);
    Event.BroadcastAndWait("un-needed broadcast");
    Wait Until (8080.mode < 99);
    Stop(other scripts in sprite);
    Event.BroadcastAndWait("clonekiller");
    Call 8080.boot;
}

Define INR/DCR(string register)(string amount) (warp=true)
{
    If (register == 6)
    {
        Call Read byte(((_registers[5] * 256) + _registers[6]))("");
        8080.cycles += 10;
    }
    Else
    {
        8080.readreturn = _registers[(register + 1)];
        8080.cycles += 5;
    }
    r.1 = ((8080.readreturn + amount) % 65536);
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    If (amount == -1)
    {
        List.ReplaceItem(_flags, 5, Operator.Round((Not ((((8080.readreturn - 1) % 16) == 15)))));
    }
    Else
    {
        List.ReplaceItem(_flags, 5, Operator.Round(((r.1 % 16) == 0)));
    }
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    If (register == 6)
    {
        Call Write byte(((_registers[5] * 256) + _registers[6]))((r.1 % 256));
    }
    Else
    {
        List.ReplaceItem(_registers, (register + 1), (r.1 % 256));
    }
}

Define Interrupt(string interrupt #) (warp=true)
{
    If (8080.mode == 0)
    {
        If (8080.InterruptFlag == 1)
        {
            Call RST(interrupt #);
        }
        8080.InterruptFlag = 0;
    }
}

Define INX/DCX(string regpair)(string amount) (warp=true)
{
    r.1 = ((((_registers[regpair] * 256) + _registers[(regpair + 1)]) + amount) % 65536);
    List.ReplaceItem(_registers, regpair, floor((r.1 / 256)));
    List.ReplaceItem(_registers, (regpair + 1), (r.1 % 256));
    8080.cycles += 5;
}

Define JMP(bool condition) (warp=true)
{
    If condition
    {
        Call Read byte(_PC)(1);
        _PC = 8080.readreturn;
    }
    Else
    {
        _PC += 2;
    }
    8080.cycles += 10;
}

Define LDA (warp=true)
{
    Call Read byte(_PC)(1);
    Call Read byte(8080.readreturn)("");
    List.ReplaceItem(_registers, 8, (8080.readreturn % 256));
    8080.cycles += 13;
    _PC += 2;
}

Define LDAX(string regpair) (warp=true)
{
    Call Read byte(((_registers[regpair] * 256) + _registers[(regpair + 1)]))("");
    List.ReplaceItem(_registers, 8, 8080.readreturn);
    8080.cycles += 7;
}

Define LHLD (warp=true)
{
    Call Read byte(_PC)(1);
    r.0 = 8080.readreturn;
    Call Read byte(r.0)("");
    List.ReplaceItem(_registers, 6, 8080.readreturn);
    Call Read byte((r.0 + 1))("");
    List.ReplaceItem(_registers, 5, 8080.readreturn);
    8080.cycles += 16;
    _PC += 2;
}

Define LXI(string register) (warp=true)
{
    Call Read byte(_PC)("");
    List.ReplaceItem(_registers, (register + 1), 8080.readreturn);
    Call Read byte((_PC + 1))("");
    List.ReplaceItem(_registers, register, 8080.readreturn);
    _PC += 2;
    8080.cycles += 10;
}

Define LXI SP (warp=true)
{
    Call Read byte(_PC)(1);
    _SP = 8080.readreturn;
    _PC += 2;
    8080.cycles += 10;
}

Define MOV(string op) (warp=true)
{
    If ((op % 8) == 6)
    {
        Call MOV RAM to reg((((floor(((op + 64) / 16)) - 4) * 2) + (((op + 64) % 16) == 14)));
    }
    Else
    {
        If (floor((op / 8)) == 6)
        {
            Call MOV reg((op % 8)) to RAM at address in regpair(5);
        }
        Else
        {
            Call MOV reg((op % 8)) to reg(floor((op / 8)));
        }
    }
}

Define MOV RAM to reg(string register) (warp=true)
{
    Call Read byte(((_registers[5] * 256) + _registers[6]))("");
    List.ReplaceItem(_registers, (register + 1), 8080.readreturn);
    8080.cycles += 7;
}

Define MOV reg(string register) to RAM at address in regpair(string pair) (warp=true)
{
    Call Write byte(((_registers[pair] * 256) + _registers[(pair + 1)]))(_registers[(register + 1)]);
    8080.cycles += 7;
}

Define MOV reg(string origin) to reg(string destination) (warp=true)
{
    List.ReplaceItem(_registers, (destination + 1), _registers[(origin + 1)]);
    8080.cycles += 5;
}

Define MVI(string register) (warp=true)
{
    Call Read byte(_PC)("");
    If (register == 6)
    {
        Call Write byte(((_registers[5] * 256) + _registers[6]))(8080.readreturn);
        8080.cycles += 3;
    }
    Else
    {
        List.ReplaceItem(_registers, (register + 1), 8080.readreturn);
    }
    _PC += 1;
    8080.cycles += 7;
}

Define opcode(string op1) (warp=true)
{
    _PC += 1;
    If (op1 < "0x10")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call LXI(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call MOV reg(7) to RAM at address in regpair(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call INX/DCX(1)(1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call INR/DCR(0)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call INR/DCR(0)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call MVI(0);
                    Stop(this script);
                }
                Call RLC/RAL();
            }
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 9)
                {
                    Call DAD(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call LDAX(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 11)
                {
                    Call INX/DCX(1)(-1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call INR/DCR(1)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call INR/DCR(1)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call MVI(1);
                    Stop(this script);
                }
                Call RRC/RAR();
            }
        }
        Stop(this script);
    }
    If (op1 < "0x20")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call LXI(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call MOV reg(7) to RAM at address in regpair(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call INX/DCX(3)(1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call INR/DCR(2)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call INR/DCR(2)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call MVI(2);
                    Stop(this script);
                }
                Call RLC/RAL((Not ()));
            }
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 9)
                {
                    Call DAD(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call LDAX(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 11)
                {
                    Call INX/DCX(3)(-1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call INR/DCR(3)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call INR/DCR(3)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call MVI(3);
                    Stop(this script);
                }
                Call RRC/RAR((Not ()));
            }
        }
        Stop(this script);
    }
    If (op1 < "0x30")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call LXI(5);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call SHLD;
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call INX/DCX(5)(1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call INR/DCR(4)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call INR/DCR(4)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call MVI(4);
                    Stop(this script);
                }
                Call DAA;
            }
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 9)
                {
                    Call DAD(5);
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call LHLD;
                    Stop(this script);
                }
                If ((op1 % 16) == 11)
                {
                    Call INX/DCX(5)(-1);
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call INR/DCR(5)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call INR/DCR(5)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call MVI(5);
                    Stop(this script);
                }
                List.ReplaceItem(_registers, 8, (255 - _registers[8]));
                8080.cycles += 4;
            }
        }
        Stop(this script);
    }
    If (op1 < "0x40")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call LXI SP;
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call STA;
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    _SP = ((_SP + 1) % 65536);
                    8080.cycles += 5;
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            If ((op1 % 16) == 4)
            {
                Call INR/DCR(6)(1);
                Stop(this script);
            }
            If ((op1 % 16) == 5)
            {
                Call INR/DCR(6)(-1);
                Stop(this script);
            }
            If ((op1 % 16) == 6)
            {
                Call MVI(6);
                Stop(this script);
            }
            List.ReplaceItem(_flags, 1, 1);
            8080.cycles += 4;
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 9)
                {
                    Call DAD SP;
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call LDA;
                    Stop(this script);
                }
                If ((op1 % 16) == 11)
                {
                    _SP = ((_SP - 1) % 65536);
                    8080.cycles += 5;
                    Stop(this script);
                }
                8080.cycles += 4;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call INR/DCR(7)(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call INR/DCR(7)(-1);
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call MVI(7);
                    Stop(this script);
                }
            }
        }
        List.ReplaceItem(_flags, 1, Operator.Round((_flags[1] == 0)));
        8080.cycles += 4;
        Stop(this script);
    }
    If (op1 < "0x80")
    {
        If (op1 == "0x76")
        {
            8080.cycles += 7;
            Stop(other scripts in sprite);
            Sensing.Ask("HALT 0x76");
            Event.Broadcast("exit emulator");
        }
        Else
        {
            Call MOV((op1 - 64));
        }
        Stop(this script);
    }
    If (op1 < "0x90")
    {
        If ((op1 % 16) < 8)
        {
            Call ADD((op1 % 8));
        }
        Else
        {
            Call ADC((op1 % 8));
        }
        Stop(this script);
    }
    If (op1 < "0xA0")
    {
        If ((op1 % 16) < 8)
        {
            Call SUB((op1 % 8));
        }
        Else
        {
            Call SBB((op1 % 8));
        }
        Stop(this script);
    }
    If (op1 < "0xB0")
    {
        If ((op1 % 16) < 8)
        {
            Call ANA((op1 % 8));
        }
        Else
        {
            Call XRA((op1 % 8));
        }
        Stop(this script);
    }
    If (op1 < "0xC0")
    {
        If ((op1 % 16) < 8)
        {
            Call ORA((op1 % 8));
        }
        Else
        {
            Call CMP((op1 % 8));
        }
        Stop(this script);
    }
    If (op1 < "0xD0")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call POP(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call JMP((_flags[7] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call JMP((Not ()));
                    Stop(this script);
                }
                Call RET((_flags[7] == 0));
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call CALL((_flags[7] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call PUSH(1);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call ADD(-1);
                    Stop(this script);
                }
            }
            Call RST(0);
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 8)
                {
                    Call RET((_flags[7] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 9)
                {
                    Call RET((Not ()));
                    8080.cycles += -1;
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call JMP((_flags[7] == 1));
                    Stop(this script);
                }
                Call JMP((Not ()));
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call CALL((_flags[7] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call CALL((Not ()));
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call ADC(-1);
                    Stop(this script);
                }
                Call RST(1);
            }
        }
        Stop(this script);
    }
    If (op1 < "0xE0")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call POP(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call JMP((_flags[1] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call OUT;
                    Stop(this script);
                }
                Call RET((_flags[1] == 0));
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call CALL((_flags[1] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call PUSH(3);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call SUB(-1);
                    Stop(this script);
                }
                Call RST(2);
            }
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 8)
                {
                    Call RET((_flags[1] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 9)
                {
                    Call RET((Not ()));
                    8080.cycles += -1;
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call JMP((_flags[1] == 1));
                    Stop(this script);
                }
                Call IN;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call CALL((_flags[1] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call CALL((Not ()));
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call SBB(-1);
                    Stop(this script);
                }
                Call RST(3);
            }
        }
        Stop(this script);
    }
    If (op1 < "0xF0")
    {
        If ((op1 % 16) < 8)
        {
            If ((op1 % 16) < 4)
            {
                If ((op1 % 16) == 1)
                {
                    Call POP(5);
                    Stop(this script);
                }
                If ((op1 % 16) == 2)
                {
                    Call JMP((_flags[3] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 3)
                {
                    Call XTHL;
                    Stop(this script);
                }
                Call RET((_flags[3] == 0));
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 4)
                {
                    Call CALL((_flags[3] == 0));
                    Stop(this script);
                }
                If ((op1 % 16) == 5)
                {
                    Call PUSH(5);
                    Stop(this script);
                }
                If ((op1 % 16) == 6)
                {
                    Call ANA(-1);
                    Stop(this script);
                }
                Call RST(4);
            }
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) < 12)
            {
                If ((op1 % 16) == 8)
                {
                    Call RET((_flags[3] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 9)
                {
                    Call PCHL;
                    Stop(this script);
                }
                If ((op1 % 16) == 10)
                {
                    Call JMP((_flags[3] == 1));
                    Stop(this script);
                }
                Call XCHG;
                Stop(this script);
            }
            Else
            {
                If ((op1 % 16) == 12)
                {
                    Call CALL((_flags[3] == 1));
                    Stop(this script);
                }
                If ((op1 % 16) == 13)
                {
                    Call CALL((Not ()));
                    Stop(this script);
                }
                If ((op1 % 16) == 14)
                {
                    Call XRA(-1);
                    Stop(this script);
                }
                Call RST(5);
            }
        }
        Stop(this script);
    }
    If ((op1 % 16) < 8)
    {
        If ((op1 % 16) < 4)
        {
            If ((op1 % 16) == 1)
            {
                Call POP PSW;
                Stop(this script);
            }
            If ((op1 % 16) == 2)
            {
                Call JMP((_flags[8] == 0));
                Stop(this script);
            }
            If ((op1 % 16) == 3)
            {
                8080.InterruptFlag = 0;
                8080.cycles += 4;
                Stop(this script);
            }
            Call RET((_flags[8] == 0));
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) == 4)
            {
                Call CALL((_flags[8] == 0));
                Stop(this script);
            }
            If ((op1 % 16) == 5)
            {
                Call PUSH PSW;
                Stop(this script);
            }
            If ((op1 % 16) == 6)
            {
                Call ORA(-1);
                Stop(this script);
            }
            Call RST(6);
        }
        Stop(this script);
    }
    Else
    {
        If ((op1 % 16) < 12)
        {
            If ((op1 % 16) == 8)
            {
                Call RET((_flags[8] == 1));
                Stop(this script);
            }
            If ((op1 % 16) == 9)
            {
                Call SPHL;
                Stop(this script);
            }
            If ((op1 % 16) == 10)
            {
                Call JMP((_flags[8] == 1));
                Stop(this script);
            }
            8080.InterruptFlag = 1;
            8080.cycles += 4;
            Stop(this script);
        }
        Else
        {
            If ((op1 % 16) == 12)
            {
                Call CALL((_flags[8] == 1));
                Stop(this script);
            }
            If ((op1 % 16) == 13)
            {
                Call CALL((Not ()));
                Stop(this script);
            }
            If ((op1 % 16) == 14)
            {
                Call CMP(-1);
                Stop(this script);
            }
            Call RST(7);
        }
    }
}

Define ORA(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = or_table[(((_registers[8] * 256) + 8080.readreturn) + 1)];
    List.ReplaceItem(_flags, 1, 0);
    List.ReplaceItem(_flags, 5, 0);
    Call parity flag(bin_table[(r.1 + 1)]);
    List.ReplaceItem(_flags, 7, Operator.Round((r.1 == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round((r.1 > 127)));
    List.ReplaceItem(_registers, 8, r.1);
}

Define OUT (warp=true)
{
    Call Read byte(_PC)("");
    Call Output to device #(8080.readreturn);
    _PC += 1;
    8080.cycles += 10;
}

Define Output to device #(string device) (warp=true)
{
    If (8080.mode == 0)
    {
        If (device == 2)
        {
            8080.shift register offset = (_registers[8] % 8);
            Stop(this script);
        }
        If (device == 3)
        {
            If (Not (((_registers[8] % 16) == 8080.lastout)))
            {
                8080.lastout = (_registers[8] % 16);
                If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 5) == 1)
                {
                    Sound.Play(3);
                }
                If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 6) == 1)
                {
                    Sound.Play(2);
                }
                If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 7) == 1)
                {
                    Sound.Play(1);
                }
                If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 8) == 1)
                {
                    Sound.Play(0);
                }
            }
            Stop(this script);
        }
        If (device == 4)
        {
            List.ReplaceItem(_registers, 9, ((_registers[8] * 256) + floor((_registers[9] / 256))));
            Stop(this script);
        }
        If (device == 5)
        {
            If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 8) == 1)
            {
                Sound.Play(4);
            }
            If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 7) == 1)
            {
                Sound.Play(5);
            }
            If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 6) == 1)
            {
                Sound.Play(6);
            }
            If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 5) == 1)
            {
                Sound.Play(7);
            }
            If (Operator.LetterOf(bin_table[(_registers[8] + 1)], 4) == 1)
            {
                Sound.Play(8);
            }
            Stop(this script);
        }
        If (device == 6)
        {
            Stop(this script);
        }
    }
    List.Show(logzz);
    Stop(all);
}

Define parity flag(string binary) (warp=true)
{
    r.7 = 0;
    control_clear_counter ?? - probably legacy function from Scratch 2.0;
    Repeat (8)
    {
        control_incr_counter ?? - probably legacy function from Scratch 2.0;
        r.7 += Operator.LetterOf(binary, control_get_counter ?? - probably legacy function from Scratch 2.0);
    }
    List.ReplaceItem(_flags, 3, (((r.7 % 2) + 1) % 2));
}

Define PCHL (warp=true)
{
    _PC = ((_registers[5] * 256) + _registers[6]);
    8080.cycles += 5;
}

Define POP(string register) (warp=true)
{
    Call Read byte(_SP)("");
    List.ReplaceItem(_registers, (register + 1), 8080.readreturn);
    Call Read byte((_SP + 1))("");
    List.ReplaceItem(_registers, register, 8080.readreturn);
    _SP += 2;
    8080.cycles += 10;
}

Define POP PSW (warp=true)
{
    Call Read byte((_SP + 1))("");
    List.ReplaceItem(_registers, 8, 8080.readreturn);
    Call Read byte(_SP)("");
    _SP += 2;
    control_clear_counter ?? - probably legacy function from Scratch 2.0;
    Repeat (8)
    {
        control_incr_counter ?? - probably legacy function from Scratch 2.0;
        List.ReplaceItem(_flags, (9 - control_get_counter ?? - probably legacy function from Scratch 2.0), Operator.LetterOf(bin_table[(8080.readreturn + 1)], control_get_counter ?? - probably legacy function from Scratch 2.0));
    }
    List.ReplaceItem(_flags, 2, 1);
    List.ReplaceItem(_flags, 4, 0);
    List.ReplaceItem(_flags, 6, 0);
    8080.cycles += 10;
}

Define PUSH(string register) (warp=true)
{
    _SP += -2;
    Call Write byte(_SP)(_registers[(register + 1)]);
    Call Write byte((_SP + 1))(_registers[register]);
    8080.cycles += 11;
}

Define PUSH PSW (warp=true)
{
    _SP += -2;
    Call Write byte((_SP + 1))(_registers[8]);
    Call Write byte(_SP)(Operator.Round(Operator.Join("0b", Operator.Join(Operator.Join(Operator.Join(_flags[8], _flags[7]), Operator.Join(0, _flags[5])), Operator.Join(Operator.Join(0, _flags[3]), Operator.Join(1, _flags[1]))))));
    8080.cycles += 11;
}

Define Read byte(string address)(string extrabytes) (warp=true)
{
    If ((16383 < address) And (8080.mode == 0))
    {
        8080.readreturn = _memory[(address - 8191)];
        If (1 == extrabytes)
        {
            8080.readreturn += (_memory[(address - 8190)] * 256);
        }
    }
    Else
    {
        8080.readreturn = _memory[((address % 65536) + 1)];
        If (1 == extrabytes)
        {
            8080.readreturn += (_memory[((address % 65536) + 2)] * 256);
        }
    }
}

Define Read from device #(string device) (warp=true)
{
    If (8080.mode == 0)
    {
        If (device == 0)
        {
            8080.readreturn = 112;
            Stop(this script);
        }
        If (device == 1)
        {
            8080.readreturn = Operator.Round(Operator.Join("0b0", Operator.Join(Operator.Join(Operator.Round(Sensing.KeyPressed(controls.SI8080[6])), Operator.Join(Operator.Round(Sensing.KeyPressed(controls.SI8080[5])), Operator.Round(Sensing.KeyPressed(controls.SI8080[4])))), Operator.Join(Operator.Join(0, Operator.Round(Sensing.KeyPressed(controls.SI8080[3]))), Operator.Join(Operator.Round(Sensing.KeyPressed(controls.SI8080[2])), Operator.Round(Sensing.KeyPressed(controls.SI8080[1])))))));
            Stop(this script);
        }
        If (device == 2)
        {
            8080.readreturn = Operator.Round(Operator.Join("0b0", Operator.Join(Operator.Join(Operator.Join(Operator.Round(Sensing.KeyPressed(controls.SI8080[9])), Operator.Round(Sensing.KeyPressed(controls.SI8080[8]))), Operator.Round(Sensing.KeyPressed(controls.SI8080[7]))), 0000)));
            Stop(this script);
        }
        If (device == 3)
        {
            List.Add(logzz, Operator.Join("IN device ID # ", device));
            8080.readreturn = floor((((_registers[9] * e ^((ln(2) * 8080.shift register offset))) % 65536) / 256));
            Stop(this script);
        }
    }
    List.Add(logzz, Operator.Join("Invalid IN device ID # ", device));
    List.Show(logzz);
    Stop(all);
}

Define render.horizontal (warp=true)
{
    Repeat (List.Length(_memorydirtyaddresses))
    {
        r.0 = _memorydirtyaddresses[last];
        List.DeleteItem(_memorydirtyaddresses, last);
        List.ReplaceItem(_memorydirtyflags, (r.0 + 1), 0);
        r.1 = _memory[(r.0 + 9217)];
        If (Not ((r.1 == _memorylastdrawndisplay[(r.0 + 1)])))
        {
            List.ReplaceItem(_memorylastdrawndisplay, (r.0 + 1), r.1);
            Motion.GoToXY((((r.0 % 32) * 8) - 130), (100 - floor((r.0 / 32))));
            r.2 = bin_table[(r.1 + 1)];
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 8) + 1)]);
            Pen.Down();
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 7) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 6) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 5) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 4) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 3) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 2) + 1)]);
            Motion.ChangeXBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 1) + 1)]);
            Motion.ChangeXBy(1);
            Pen.Clear();
        }
    }
}

Define render.vertical (warp=true)
{
    Repeat (List.Length(_memorydirtyaddresses))
    {
        r.0 = _memorydirtyaddresses[last];
        List.DeleteItem(_memorydirtyaddresses, last);
        List.ReplaceItem(_memorydirtyflags, (r.0 + 1), 0);
        r.1 = _memory[(r.0 + 9217)];
        If (Not ((r.1 == _memorylastdrawndisplay[(r.0 + 1)])))
        {
            List.ReplaceItem(_memorylastdrawndisplay, (r.0 + 1), r.1);
            Motion.GoToXY((floor((r.0 / 32)) - 130), (((r.0 % 32) * 8) - 150));
            r.2 = bin_table[(r.1 + 1)];
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 8) + 1)]);
            Pen.Down();
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 7) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 6) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 5) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 4) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 3) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 2) + 1)]);
            Motion.ChangeYBy(1);
            Pen.SetPenColorToColor(_colours[(Operator.LetterOf(r.2, 1) + 1)]);
            Pen.Down();
            Pen.Clear();
        }
    }
}

Define RET(bool condition) (warp=true)
{
    If condition
    {
        Call Read byte(_SP)(1);
        _PC = 8080.readreturn;
        _SP += 2;
        8080.cycles += 6;
    }
    8080.cycles += 5;
}

Define RLC/RAL(bool using carry) (warp=true)
{
    r.0 = ((_registers[8] * 2) + floor((_registers[8] / 128)));
    If using carry
    {
        If (Not (((r.0 % 2) == _flags[1])))
        {
            If ((r.0 % 2) == 1)
            {
                r.0 += -1;
            }
            Else
            {
                r.0 += 1;
            }
        }
    }
    List.ReplaceItem(_flags, 1, Operator.Round((_registers[8] > 127)));
    List.ReplaceItem(_registers, 8, (r.0 % 256));
    8080.cycles += 4;
}

Define RRC/RAR(bool using carry) (warp=true)
{
    r.0 = ((floor((_registers[8] / 2)) + ((_registers[8] % 2) * 128)) % 256);
    If using carry
    {
        If (Not (((r.0 > 127) == _flags[1])))
        {
            If (r.0 > 127)
            {
                r.0 += -128;
            }
            Else
            {
                r.0 += 128;
            }
        }
    }
    List.ReplaceItem(_flags, 1, (_registers[8] % 2));
    List.ReplaceItem(_registers, 8, (r.0 % 256));
    8080.cycles += 4;
}

Define RST(string address) (warp=true)
{
    _SP += -2;
    Call Write byte(_SP)((_PC % 256));
    Call Write byte((_SP + 1))(floor((_PC / 256)));
    _PC = (address * 8);
    8080.cycles += 11;
}

Define SBB(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = (_registers[8] + (256 - (8080.readreturn + _flags[1])));
    List.ReplaceItem(_flags, 1, Operator.Round((256 > r.1)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round((((_registers[8] % 16) + ((256 - (8080.readreturn + _flags[1])) % 16)) > 15)));
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    List.ReplaceItem(_registers, 8, (r.1 % 256));
}

Define Set FPS (warp=true)
{
    FPS = (1 / ((Sensing.DaysSince2000() - frame) * 86400));
    frame = Sensing.DaysSince2000();
}

Define SHLD (warp=true)
{
    Call Read byte(_PC)(1);
    Call Write byte(8080.readreturn)(_registers[6]);
    Call Write byte((8080.readreturn + 1))(_registers[5]);
    8080.cycles += 16;
    _PC += 2;
}

Define SPHL (warp=true)
{
    _SP = ((_registers[5] * 256) + _registers[6]);
    8080.cycles += 5;
}

Define STA (warp=true)
{
    Call Read byte(_PC)(1);
    Call Write byte(8080.readreturn)(_registers[8]);
    8080.cycles += 13;
    _PC += 2;
}

Define Step CPU(string cycles) (warp=true)
{
    8080.cycles = 0;
    Repeat Until ((8080.cycles == cycles) Or (cycles < 8080.cycles))
    {
        Call opcode(_memory[(_PC + 1)]);
        If (8080.mode == 1)
        {
            If (_PC == 0)
            {
                Stop(other scripts in sprite);
                List.Add(logzz, "Jump to 0: CP/M reboot");
                List.Show(logzz);
                Stop(all);
            }
            If (_PC == 5)
            {
                Event.BroadcastAndWait("CP/M Call");
            }
        }
    }
}

Define SUB(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    8080.readreturn = (256 - 8080.readreturn);
    r.1 = (_registers[8] + 8080.readreturn);
    List.ReplaceItem(_flags, 1, Operator.Round((256 > r.1)));
    Call parity flag(bin_table[((r.1 % 256) + 1)]);
    List.ReplaceItem(_flags, 5, Operator.Round((((_registers[8] % 16) + (8080.readreturn % 16)) > 15)));
    List.ReplaceItem(_flags, 7, Operator.Round(((r.1 % 256) == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round(((r.1 % 256) > 127)));
    List.ReplaceItem(_registers, 8, (r.1 % 256));
}

Define Write byte(string address)(string byte) (warp=true)
{
    If (8080.mode == 0)
    {
        If ((8191 < address) And (address < 16384))
        {
            If (address > 9215)
            {
                If (_memorydirtyflags[(address - 9215)] == 0)
                {
                    List.ReplaceItem(_memorydirtyflags, (address - 9215), 1);
                    List.Add(_memorydirtyaddresses, (address - 9216));
                }
            }
            List.ReplaceItem(_memory, (address + 1), byte);
        }
    }
    Else
    {
        List.ReplaceItem(_memory, (address + 1), byte);
    }
}

Define XCHG (warp=true)
{
    r.0 = _registers[5];
    r.1 = _registers[6];
    List.ReplaceItem(_registers, 5, _registers[3]);
    List.ReplaceItem(_registers, 6, _registers[4]);
    List.ReplaceItem(_registers, 3, r.0);
    List.ReplaceItem(_registers, 4, r.1);
    8080.cycles += 5;
}

Define XRA(string register) (warp=true)
{
    If (-1 < register)
    {
        If (register == 6)
        {
            Call Read byte(((_registers[5] * 256) + _registers[6]))("");
            8080.cycles += 7;
        }
        Else
        {
            8080.readreturn = _registers[(register + 1)];
            8080.cycles += 4;
        }
    }
    Else
    {
        Call Read byte(_PC)("");
        _PC += 1;
        8080.cycles += 7;
    }
    r.1 = xor_table[(((_registers[8] * 256) + 8080.readreturn) + 1)];
    List.ReplaceItem(_flags, 1, 0);
    List.ReplaceItem(_flags, 5, 0);
    Call parity flag(bin_table[(r.1 + 1)]);
    List.ReplaceItem(_flags, 7, Operator.Round((r.1 == 0)));
    List.ReplaceItem(_flags, 8, Operator.Round((r.1 > 127)));
    List.ReplaceItem(_registers, 8, r.1);
}

Define XTHL (warp=true)
{
    Call Read byte(_SP)("");
    Call Write byte(_SP)(_registers[6]);
    List.ReplaceItem(_registers, 6, 8080.readreturn);
    Call Read byte((_SP + 1))("");
    Call Write byte((_SP + 1))(_registers[5]);
    List.ReplaceItem(_registers, 5, 8080.readreturn);
    8080.cycles += 18;
}


//----- Orphaned blocks -----------------------------------------------------------------------------------------------

r.7 = Operator.Join(Operator.LetterOf("0123456789ABCDEF", ((floor((_PC / 4096)) % 16) + 1)), Operator.Join(Operator.LetterOf("0123456789ABCDEF", ((floor((_PC / 256)) % 16) + 1)), Operator.Join(Operator.LetterOf("0123456789ABCDEF", ((floor((_PC / 16)) % 16) + 1)), Operator.LetterOf("0123456789ABCDEF", ((_PC % 16) + 1)))))

List.ReplaceItem(_flags, 5, Operator.Round(((((_registers[8] % 16) + (8080.readreturn % 16)) % 17) > 0)))

Motion.SetY(100)

Motion.SetX(-130)

Repeat (60)



//----- Costumes ------------------------------------------------------------------------------------------------------

blank.svg
CPM.svg
Manual.svg
SI.svg


//----- Sounds --------------------------------------------------------------------------------------------------------

0.wav
1.wav
2.wav
3.wav
4.wav
5.wav
6.wav
7.wav
8.wav
9.wav
11.wav
12.wav
13.wav
14.wav
15.wav
16.wav
17.wav
18.wav
